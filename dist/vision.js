/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var vision;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./build/index.js":
/*!************************!*\
  !*** ./build/index.js ***!
  \************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports.LSystem = __webpack_require__(/*! ./src/algorithms/LSystem.js */ \"./src/algorithms/LSystem.js\");\nmodule.exports.optimum_solution_solver = __webpack_require__(/*! ./src/algorithms/optimum_solution_solver.js */ \"./src/algorithms/optimum_solution_solver.js\");\nmodule.exports.canvas = __webpack_require__(/*! ./src/canvas/canvas.js */ \"./src/canvas/canvas.js\");\nmodule.exports.color = __webpack_require__(/*! ./src/canvas/color.js */ \"./src/canvas/color.js\");\nmodule.exports.iterator = __webpack_require__(/*! ./src/utils/iterator.js */ \"./src/utils/iterator.js\");\nmodule.exports.random = __webpack_require__(/*! ./src/utils/random.js */ \"./src/utils/random.js\");\nmodule.exports.tools = __webpack_require__(/*! ./src/utils/tools.js */ \"./src/utils/tools.js\");\nmodule.exports.area = __webpack_require__(/*! ./src/vector/area.js */ \"./src/vector/area.js\");\nmodule.exports.border = __webpack_require__(/*! ./src/vector/border.js */ \"./src/vector/border.js\");\nmodule.exports.coor = __webpack_require__(/*! ./src/vector/coor.js */ \"./src/vector/coor.js\");\nmodule.exports.field = __webpack_require__(/*! ./src/vector/field.js */ \"./src/vector/field.js\");\nmodule.exports.matrix = __webpack_require__(/*! ./src/vector/matrix.js */ \"./src/vector/matrix.js\");\nmodule.exports.particle = __webpack_require__(/*! ./src/vector/particle.js */ \"./src/vector/particle.js\");\nmodule.exports.tracker = __webpack_require__(/*! ./src/vector/tracker.js */ \"./src/vector/tracker.js\");\nmodule.exports.vector = __webpack_require__(/*! ./src/vector/vector.js */ \"./src/vector/vector.js\");\nmodule.exports.capturer = __webpack_require__(/*! ./src/views/capturer.js */ \"./src/views/capturer.js\");\nmodule.exports.randerer = __webpack_require__(/*! ./src/views/randerer.js */ \"./src/views/randerer.js\");\nmodule.exports.views = __webpack_require__(/*! ./src/views/views.js */ \"./src/views/views.js\");\nmodule.exports.point_capturer = __webpack_require__(/*! ./src/viewtools/point_capturer.js */ \"./src/viewtools/point_capturer.js\");\n\n\n//# sourceURL=webpack://vision/./build/index.js?");

/***/ }),

/***/ "./src/algorithms/LSystem.js":
/*!***********************************!*\
  !*** ./src/algorithms/LSystem.js ***!
  \***********************************/
/***/ ((module) => {

eval("/****************************************\r\n * Name: L-System | L系统\r\n * Date: 2022-09-11\r\n * Author: Ais\r\n * Project: \r\n * Desc: 一种并行重写系统和一种形式语法\r\n * Version: 0.1\r\n****************************************/\r\n\r\n//L系统\r\nclass LSystem {\r\n\r\n    /*----------------------------------------\r\n    @class: L系统\r\n    @desc: \r\n        G = (S, V, P)\r\n    @property: \r\n        * S(str): 系统起始状态(公理)\r\n        * V(list:str): 符号表(终结符号&非终结符)\r\n        * P(obj|map): 生成式\r\n        * ops(obj|map): 符号->行为映射表\r\n    @method: \r\n        * method: func\r\n    @exp: \r\n        ls = new LSystem({\r\n            \"S\": \"A\",\r\n            \"V\": [\"A\", \"B\", \"[\", \"]\"],\r\n            \"P\": {\r\n                \"A\": \"B[A]A\",\r\n                \"B\": \"BB\"\r\n            },\r\n            \"ops\": {\r\n                \"A\": (st) => {\r\n                    canvas.line(st.p.clone(), st.p.add(st.v));\r\n                },\r\n                \"B\": (st) => {\r\n                    canvas.line(st.p.clone(), st.p.add(st.v));\r\n                },\r\n                \"[\": (st) => {\r\n                    st.stack.unshift([st.p.clone(), st.v.clone()]);\r\n                    st.v.rotate(st.rad);\r\n                },\r\n                \"]\": (st) => {\r\n                    let status = st.stack.shift();\r\n                    st.p = status[0], st.v = status[1];\r\n                    st.v.rotate(-st.rad);\r\n                }\r\n            }\r\n        });\r\n    ----------------------------------------*/\r\n    constructor({S=\"\", V=[], P={}, ops={}} = {}) {\r\n        //系统起始状态(公理)\r\n        this.S = S;\r\n        //符号表(终结符号&非终结符)\r\n        this.V = V;\r\n        //生成式\r\n        this.P = P;\r\n        //符号->行为映射表\r\n        this.ops = ops;\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 迭代\r\n    @desc: 根据生成式生成下一代语句\r\n    @params: \r\n        * s(str): 语句\r\n    @return(str) \r\n    ----------------------------------------*/\r\n    next(s=this.S) {\r\n        let _s = \"\";\r\n        for(let i=0, n=s.length; i<n; i++) {\r\n            _s += (s[i] in this.P ? this.P[s[i]] : s[i]);\r\n        }\r\n        return _s;\r\n    } \r\n\r\n    /*----------------------------------------\r\n    @func: 推导(重复迭代)\r\n    @desc: 根据生成式从公理出发推导到第n代语句\r\n    @params: \r\n        * n(int:>=0): 迭代代数\r\n    @return(str): 语句\r\n    ----------------------------------------*/\r\n    gen(n=0) {\r\n        let s = this.S;\r\n        for(let i=0; i<n; i++) {\r\n            s = this.next(s);\r\n        }\r\n        return s;\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 推导(迭代器)\r\n    @desc: 以迭代器的形式进行推导，用于输出中间代语句\r\n    @params: \r\n        * n(int:>=0): 迭代代数\r\n    @return(iterator): 迭代器\r\n    @exp: \r\n        it = ls.iter(5);\r\n        it.next().value;\r\n    ----------------------------------------*/\r\n    *iter(n=0) {\r\n        let s = this.S;\r\n        for(let i=0; i<n; i++) {\r\n            s = this.next(s);\r\n            yield s;\r\n        }\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 绘制/行动\r\n    @desc: 根据语句和ops进行绘制\r\n    @params: \r\n        * s(str): 语句\r\n        * status(obj): 状态表\r\n    @return(status): 状态表\r\n    @exp: \r\n        ls.act(ls.gen(5), {\r\n            \"p\": new Vector(canvas.cx, canvas.height),\r\n            \"v\": new Vector(0, -10),\r\n            \"rad\": Tools.ATR(45),\r\n            \"stack\": []\r\n        })\r\n    ----------------------------------------*/\r\n    act(s, status) {\r\n        for(let i=0, n=s.length; i<n; i++) {\r\n            (s[i] in this.ops) && this.ops[s[i]](status);\r\n        }\r\n        return status;\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 绘制/行动(迭代器模式)\r\n    @exp: \r\n        act_it = ls.act(ls.gen(3), {\r\n            \"p\": new Vector(canvas.cx, canvas.height),\r\n            \"v\": new Vector(0, -1),\r\n            \"rad\": Tools.ATR(25),\r\n            \"stack\": []\r\n        });\r\n        act_it.next();\r\n    ----------------------------------------*/\r\n    *actIter(s, status) {\r\n        for(let i=0, n=s.length; i<n; i++) {\r\n            yield (s[i] in this.ops) && this.ops[s[i]](status);\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\nmodule.exports.LSystem = LSystem;\n\n//# sourceURL=webpack://vision/./src/algorithms/LSystem.js?");

/***/ }),

/***/ "./src/algorithms/optimum_solution_solver.js":
/*!***************************************************!*\
  !*** ./src/algorithms/optimum_solution_solver.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/****************************************\r\n * Name: 最优解通用求解器\r\n * Date: 2022-07-11\r\n * Author: Ais\r\n * Project: Vision\r\n * Desc: 给定一个目标函数，计算该函数的数值最优解\r\n * Version: 0.1\r\n****************************************/\r\n\r\nconst Vector = (__webpack_require__(/*! ../vector/vector */ \"./src/vector/vector.js\").Vector);\r\nconst Particle = (__webpack_require__(/*! ../vector/particle */ \"./src/vector/particle.js\").Particle);\r\n\r\n/***************************************  \r\n算法思路:\r\n给定一个目标函数f(x), 其中x是定义域为R*n的向量。现在构造一个求解器s(solver), solver有一个临近坐标集，\r\n这个集合是其每次迭代后的可能位置。solver在每次迭代时从中选取f(x)的最优解进行移动，直到停机(当临近集中\r\n的所有值都不是最优时停机)。\r\n通过上述算法构建的solver求解的可能是局部最优解。为了应对这种情况，可能通过构建一个求解器集群来避免。\r\n通过随机生成solver的初始位置，让N个solver均匀分布在定义域上。但这N个solver停机时，从中选择一个\r\n最优解作为全局最优解。\r\n****************************************/\r\n\r\n//局部最优解求解器\r\nclass Solver extends Particle {\r\n\r\n    /*----------------------------------------\r\n    @func: 局部最优值求解器\r\n    @desc: 通过迭代来求解指定域下目标函数的局部最优解\r\n    @params: \r\n        * tfunc(function): 目标函数\r\n        * ps(Vector): 起始位置\r\n        * val_type(str): 最优解类型(min || max)\r\n    ----------------------------------------*/\r\n    constructor(tfunc, ps, val_type=\"min\") {\r\n        super();\r\n        //目标函数\r\n        this.tfunc = tfunc;\r\n        //求解域(定义域的子域)\r\n        this.dod = [];\r\n        //最优值类型\r\n        this.val_type = val_type;\r\n        //局部最优解坐标\r\n        this.p = ps;\r\n        //最优值\r\n        this.val = (this.val_type == \"min\" ? Infinity : -Infinity);\r\n        //速度集(临近坐标集)\r\n        this.vs = [];\r\n        //停机状态\r\n        this._END = false;\r\n    }\r\n\r\n    action() {\r\n        if(!this._END) {\r\n            let _END = true;\r\n            for(let i=0, end=this.vs.length; i<end; i++) {\r\n                //计算目标函数值\r\n                let _pv = Vector.add(this.p, this.vs[i]);\r\n                let _val = this.tfunc(_pv);\r\n                //移动到最优解坐标\r\n                if((this.val_type==\"min\" && _val <= this.val) || (this.val_type==\"max\" && val >= this.val)) {\r\n                    this.val = _val; this.p = _pv;\r\n                    _END = false;\r\n                }\r\n                //停机(超过求解域)\r\n                if(!_pv.in(this.dod)) { _END = true; }\r\n            }\r\n            this._END = _END;\r\n        }\r\n        return this.p;\r\n    }\r\n\r\n    end() { return this._END; }\r\n}\r\n\r\n\r\n//求解器集群\r\nclass OptimumSolutionSolvers {\r\n\r\n    /*----------------------------------------\r\n    @func: 求解器集群\r\n    @desc: 通过在求解域上均匀分布的求解器来求解全局最优值\r\n    @property: \r\n        * n(number): 求解器数量\r\n        * count(number): 迭代计数器, 用于控制迭代次数\r\n        * tfunc(function): 目标函数\r\n        * dod(list:number): 求解域 -> [[0, width], [0, height]]\r\n        * vs(list:Vector): 求解器速度集, 默认采用8个临近点\r\n        * vsd(number): 默认速度集的步长\r\n        * val_type(str): 最优解类型(min || max)\r\n        * os_val(number): 最优解值\r\n        * os_p(Vector): 最优解坐标\r\n    @return(type): \r\n    @exp: \r\n    ----------------------------------------*/\r\n    constructor() {\r\n        //求解器数量\r\n        this.n = 30;\r\n        //求解器集群\r\n        this.solvers = [];\r\n        //迭代次数\r\n        this.count = Infinity;\r\n        //目标函数\r\n        this.tfunc = null;\r\n        //求解域\r\n        this.dod = [];\r\n        //求解器速度集\r\n        this.vs = null;\r\n        //求解器速度集步长\r\n        this.vsd = 1;\r\n        //最优值类型\r\n        this.val_type = \"min\";\r\n        //最优值\r\n        this.os_val = null;\r\n        //最优值坐标\r\n        this.os_p = null;\r\n        //停机状态\r\n        this._END = false;\r\n    }\r\n\r\n    //初始化求解器\r\n    init() {\r\n        //最优解初始值\r\n        this.os_val = (this.val_type == \"min\" ? Infinity : -Infinity);\r\n        //构建速度集\r\n        if(this.vs == null) {\r\n            this.vs = [\r\n                new Vector(-1, -1).norm(this.vsd), new Vector(0, -1).norm(this.vsd), new Vector(1, -1).norm(this.vsd),\r\n                new Vector(-1, 0).norm(this.vsd),                                    new Vector(1, 0).norm(this.vsd),\r\n                new Vector(-1, 1).norm(this.vsd),  new Vector(0, 1).norm(this.vsd),  new Vector(1, 1).norm(this.vsd),\r\n            ]\r\n        }\r\n        //构建求解器\r\n        for(let i=0; i<this.n; i++) {\r\n            let _solver = new Solver(this.tfunc, Vector.random(this.dod), this.val_type);\r\n            _solver.dod = this.dod; _solver.vs = this.vs;\r\n            this.solvers.push(_solver);\r\n        }\r\n    }\r\n    \r\n    //迭代\r\n    next() {\r\n        if(this._END || this.count<0) {\r\n            this._END = true;\r\n            return this.os_p;\r\n        }\r\n        let _END = true;\r\n        for(let i=0, end=this.solvers.length; i<end; i++) {\r\n            this.solvers[i].action();\r\n            _END = _END & this.solvers[i].end();\r\n            if((this.val_type==\"min\" && this.solvers[i].val <= this.os_val) || (this.val_type==\"max\" && this.solvers[i].val >= this.os_val)) {\r\n                this.os_val = this.solvers[i].val; this.os_p = this.solvers[i].p;\r\n            }\r\n        }\r\n        this._END = _END;\r\n        this.count--;\r\n        return this.os_p;\r\n    }\r\n\r\n    //停机状态\r\n    end() { return this._END; }\r\n}\r\n\r\n\r\nmodule.exports.OptimumSolutionSolvers = OptimumSolutionSolvers;\n\n//# sourceURL=webpack://vision/./src/algorithms/optimum_solution_solver.js?");

/***/ }),

/***/ "./src/canvas/canvas.js":
/*!******************************!*\
  !*** ./src/canvas/canvas.js ***!
  \******************************/
/***/ ((module) => {

eval("/****************************************\r\n * Name: HTML5 Canvas 对象\r\n * Date: 2022-07-05\r\n * Author: Ais\r\n * Project: Vision\r\n * Desc: 对canvas接口进行二次封装\r\n * Version: 0.1\r\n****************************************/\r\n\r\nclass Canvas {\r\n\r\n    /*----------------------------------------\r\n    @func: Canvas对象\r\n    @params: \r\n        * canvas_id(str): canvas标签的id\r\n        * width(int): 画布宽度\r\n        * height(int): 画布高度\r\n        * BGC(str): 画布的背景颜色\r\n    @return(obj): canvas对象\r\n    @exp: \r\n        const canvas = new Canvas(\"vision_canvas\", 3840, 2160);\r\n    ----------------------------------------*/\r\n    constructor(canvas_id, width, height, BGC='rgb(50, 50, 50)') {\r\n        //获取canvas标签\r\n        this.canvas = document.getElementById(canvas_id);\r\n        //设置canvas尺寸\r\n        this._width = this.canvas.width = width || window.screen.width;\r\n        this._height = this.canvas.height = height || window.screen.height;\r\n        //中心点坐标\r\n        this._cx = parseInt(this._width / 2);\r\n        this._cy = parseInt(this._height / 2);\r\n        //获取绘图上下文(2D)\r\n        this.ctx = this.canvas.getContext(\"2d\");\r\n        //默认背景色\r\n        this.BGC = BGC;\r\n        //point样式\r\n        this.POINT = {\r\n            //大小(半径)\r\n            \"R\": 2,\r\n            //颜色\r\n            \"C\": \"#FFFFFF\"\r\n        }\r\n        this.refresh();\r\n    }\r\n\r\n    //设置canvas尺寸\r\n    get width() { return this._width; }\r\n    set width(w) { this._width = this.canvas.width = w; this._cx = parseInt(this._width / 2); this.refresh(); }\r\n    get height() { return this._height; }\r\n    set height(h) { this._height = this.canvas.height = h; this._cy = parseInt(this._height / 2); this.refresh(); }\r\n    get cx() { return this._cx; }\r\n    get cy() { return this._cy; }\r\n\r\n    //设置颜色(strokeStyle && fillStyle)\r\n    set colorStyle(color) {\r\n        this.ctx.strokeStyle = this.ctx.fillStyle = color;\r\n    }\r\n\r\n    //重置画布尺寸\r\n    resize(width, height) {\r\n        this.width = parseInt(width) || window.screen.width;\r\n        this.height = parseInt(height) || window.screen.height;\r\n    }\r\n\r\n    //刷新画布\r\n    refresh(color){\r\n        this.ctx.fillStyle = color || this.BGC;\r\n        this.ctx.fillRect(0, 0, this._width, this._height);\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 绘制点(point)\r\n    @desc: 绘制坐标为(x, y)的点\r\n    @params: \r\n        * x: x坐标参数\r\n        * y: y坐标参数\r\n        * color: 颜色\r\n        * r: 半径\r\n    @exp:\r\n        * point(100, 100)\r\n        * point(Vector(100, 100)) \r\n        * point({\"x\":100, \"y\":100}) \r\n    ----------------------------------------*/\r\n    point(x, y, color=null, r=null) {\r\n        if(typeof arguments[0] != \"number\") {\r\n            x = arguments[0].x; y = arguments[0].y;\r\n        }\r\n        this.ctx.strokeStyle = this.ctx.fillStyle = (color || this.POINT.C);\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(x, y, r || this.POINT.R, 0, 2*Math.PI);\r\n        this.ctx.stroke(); \r\n        this.POINT.R > 1 && this.ctx.fill();\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 绘制线段(line)\r\n    @desc: 绘制一条从起始点(xs, ys)到终止点(xe, ye)的线段\r\n    @params: \r\n        * (xs, ys): 起始点坐标\r\n        * (xe, ye): 终止点坐标\r\n    @exp:\r\n        * line(100, 100, 300, 300)\r\n        * line(Vector(100, 100), Vector(300, 300)) \r\n    ----------------------------------------*/\r\n    line(xs, ys, xe, ye) {\r\n        if(typeof arguments[0] != \"number\") {\r\n            xs = arguments[0].x; ys = arguments[0].y;\r\n            xe = arguments[1].x; ye = arguments[1].y;\r\n        }\r\n        this.ctx.beginPath();\r\n        this.ctx.moveTo(xs, ys);\r\n        this.ctx.lineTo(xe, ye);   \r\n        this.ctx.stroke(); \r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 绘制线集\r\n    @desc: 根据顶点集绘制线集\r\n    @params: \r\n        * ps: 顶点集 -> [[x1, y1], [x2, y2], ..., [xn, yn]] || [v1, v2, v3, ..., vn]\r\n        * color(str || Color(颜色对象)): 线段颜色样式 \r\n        * close: 是否闭合\r\n    @exp:\r\n        * lines([[100, 100], [300, 300]])\r\n        * lines([Vector(100, 100), Vector(300, 300)]) \r\n    ----------------------------------------*/\r\n    lines(ps, color='rgb(255, 255, 255)', close=false) {\r\n        //判断点集元素类型\r\n        let isVector = (ps[0].x != undefined);\r\n        //判断是否是颜色对象\r\n        let isColor = (color.color != undefined);\r\n        //绘制线段\r\n        for(let i=0, n=ps.length, end=(close ? n : n-1); i<end; i++) {\r\n            this.ctx.beginPath();\r\n            this.ctx.strokeStyle = (isColor ? color.color() : color);\r\n            if(isVector) {\r\n                this.ctx.moveTo(ps[i].x, ps[i].y); this.ctx.lineTo(ps[(i+1)%n].x, ps[(i+1)%n].y);\r\n            } else {\r\n                this.ctx.moveTo(ps[i][0], ps[i][1]); this.ctx.lineTo(ps[(i+1)%n][0], ps[(i+1)%n][1]);\r\n            }\r\n            this.ctx.stroke();\r\n        }\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 绘制圆\r\n    @desc: 绘制圆心坐标为(x, y), 半径为r的圆\r\n    @params: \r\n        * (x, y): 圆心坐标\r\n        * r: 半径\r\n        * color: 颜色\r\n    @exp:\r\n        * circle(100, 100, 5) \r\n    ----------------------------------------*/\r\n    circle(x, y, r, color=null) {\r\n        if(color){ this.ctx.strokeStyle = this.ctx.fillStyle = color};\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(x, y, r, 0, 2*Math.PI);\r\n        this.ctx.stroke(); \r\n        color && this.ctx.fill();\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 绘制矩形\r\n    @desc: 绘制中心坐标为(x, y), x轴半径为rx, y轴半径为ry的矩形\r\n    @params: \r\n        * (x, y): 中心坐标\r\n        * rx: x轴半径为rx\r\n        * ry: y轴半径为rx\r\n    @exp:\r\n        * rect(100, 100, 50, 100) \r\n        * rect(100, 100, 50, 50) \r\n    ----------------------------------------*/\r\n    rect(x, y, rx, ry) {\r\n        this.ctx.beginPath();\r\n        this.ctx.rect(x-rx, y-ry, rx*2, ry*2);\r\n        this.ctx.stroke();\r\n    }\r\n}\r\n\r\n\r\nmodule.exports.Canvas = Canvas;\n\n//# sourceURL=webpack://vision/./src/canvas/canvas.js?");

/***/ }),

/***/ "./src/canvas/color.js":
/*!*****************************!*\
  !*** ./src/canvas/color.js ***!
  \*****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/****************************************\r\n * Name: color | 颜色\r\n * Date: 2022-07-018\r\n * Author: Ais\r\n * Project: Vision\r\n * Desc: 颜色容器\r\n * Version: 0.1\r\n****************************************/\r\n\r\nconst Vector = (__webpack_require__(/*! ../vector/vector.js */ \"./src/vector/vector.js\").Vector);\r\n\r\n//颜色向量\r\nclass ColorVector extends Vector {\r\n\r\n    /*----------------------------------------\r\n    @class: 颜色向量(Vector)\r\n    @desc: \r\n        用向量来描述颜色，一个颜色表达式可以看作RGB空间中的一个向量，之所以采用\r\n        向量的形式来描述颜色在于，可以通过这种方式替换粒子中的位置向量，\r\n        来描述颜色向量在颜色空间中的移动，从而构建颜色渐变器。\r\n    @property: \r\n        * r/g/b(get/set): 颜色的RGB值分量\r\n        * a(get/set): alpht通道分量\r\n    @method: \r\n        * color(): 返回颜色表达式 -> 'rgb(r, g, b)'\r\n        * clone(): 复制颜色向量\r\n    @exp:\r\n        * new ColorVector(100, 200, 300).color() -> 'rgb(100, 200, 300)';\r\n    ----------------------------------------*/\r\n    constructor(r=0, g=0, b=0, a=1) {\r\n        super();\r\n        //颜色分量\r\n        this._v = a==1 ? [r, g, b] : [r, g, b, a];\r\n    }\r\n\r\n    get r(){ return this._v[0]; }\r\n    get g(){ return this._v[1]; }\r\n    get b(){ return this._v[2]; }\r\n    get a(){ return this._v[3]; }\r\n    set r(val){ this._v[0] = val; }\r\n    set g(val){ this._v[1] = val; }\r\n    set b(val){ this._v[2] = val; }\r\n    set a(val){ this._v[3] = val; }\r\n\r\n    color(tolist=false) {\r\n        if(this._v.length<=3) {\r\n            return tolist ? [this._v[0], this._v[1], this._v[2]] : `rgb(${this._v[0]}, ${this._v[1]}, ${this._v[2]})`;\r\n        } else {\r\n            return tolist ? [this._v[0], this._v[1], this._v[2], this._v[3]] : `rgb(${this._v[0]}, ${this._v[1]}, ${this._v[2]})`;\r\n        }\r\n    }\r\n    val(tolist=false) { return this.color(tolist); }\r\n\r\n    clone() {\r\n        return new ColorVector(...this._v);\r\n    }\r\n}\r\n\r\n\r\n//颜色渐变器\r\nclass ColorGradient {\r\n\r\n    /*----------------------------------------\r\n    @class: 线性颜色渐变器\r\n    @desc: 一种迭代器，用于产生渐变色。\r\n    @property: \r\n        * scv(ColorVector): 起始颜色向量\r\n        * ecv(ColorVector): 终止颜色向量\r\n        * cv(ColorVector): 当前颜色向量\r\n        * n(number): 渐变次数，用于计算每次迭代时的颜色增量\r\n        * _count(number): 内部计数器，用于记录当前迭代次数\r\n        * _dcv(ColorVector): 每次迭代的颜色增量\r\n    @method: \r\n        * color(): 返回颜色表达式 -> 'rgb(r, g, b)'\r\n    @exp: \r\n        new ColorGradient([100, 200, 200], [50, 50, 50], 100);\r\n    ----------------------------------------*/\r\n    constructor(start_color, end_color, n) {\r\n        //起始颜色向量\r\n        this.scv = new ColorVector(...start_color);\r\n        //终止颜色向量\r\n        this.ecv = new ColorVector(...end_color);\r\n        //当前颜色\r\n        this.cv = this.scv.clone();\r\n        //渐变次数\r\n        this.n = n; \r\n        //计数器\r\n        this._count = n;\r\n        //计算颜色增量\r\n        this._dcv = Vector.sub(this.ecv, this.scv).norm(Vector.dist(this.ecv, this.scv)/n);\r\n    }\r\n\r\n    color(tolist=false) {\r\n        let color_val = this.cv.color(tolist);\r\n        if(this._count > 0) { this.cv.add(this._dcv); }\r\n        this._count--;\r\n        return color_val;\r\n    } \r\n    val(tolist=false) { return this.color(tolist); }\r\n\r\n    end() {\r\n        return !(this._count > 0);\r\n    }\r\n\r\n}\r\n\r\n\r\nmodule.exports.ColorVector = ColorVector;\r\nmodule.exports.ColorGradient = ColorGradient;\r\n\r\n\r\n\n\n//# sourceURL=webpack://vision/./src/canvas/color.js?");

/***/ }),

/***/ "./src/utils/iterator.js":
/*!*******************************!*\
  !*** ./src/utils/iterator.js ***!
  \*******************************/
/***/ ((module) => {

eval("/****************************************\r\n * Name: 迭代器\r\n * Date: 2022-07-26\r\n * Author: Ais\r\n * Project: Vision\r\n * Desc: 实现迭代器对象\r\n * Version: 0.1\r\n****************************************/\r\n\r\n//迭代器(基类)\r\nclass Iterator {\r\n\r\n    /*----------------------------------------\r\n    @class: 迭代器(基类)\r\n    @desc: 通过val接口实现值的迭代\r\n    @property: \r\n        * _val(any): 迭代器的值\r\n    @method: \r\n        * val(): 迭代逻辑实现, 每次调用返回迭代后的值 -> _val\r\n        * end(): 停机状态, 判断迭代器是否停机(迭代结束)\r\n        * tolist(): 迭代并输出值的变化过程 -> [_val(0), _val(1), _val(2) ... _val(n)]\r\n    @exp:\r\n    ----------------------------------------*/\r\n    constructor(val) {\r\n        //值\r\n        this._val = val;\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 值迭代逻辑接口\r\n    @desc: 实现迭代逻辑,并返回迭代的值\r\n    @return(any): this._val\r\n    ----------------------------------------*/\r\n    val() {\r\n        return this._val;\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 停机状态\r\n    @desc: 判断迭代器是否迭代结束\r\n    @return(bool) \r\n    ----------------------------------------*/\r\n    end() {\r\n        return false;\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 数组转换器\r\n    @desc: 进行迭代，并输出值的变换过程\r\n    @params:\r\n        * n(number): 迭代次数，用于处理不会停机的迭代器\r\n    @return(list:any): [_val(0), _val(1), _val(2) ... _val(n)]\r\n    ----------------------------------------*/\r\n    tolist(n=500) {\r\n        let vals = [];\r\n        for(let i=0; i<n; i++) { \r\n            vals.push(this.val());\r\n            if(this.end()) { break; }\r\n        }\r\n        return vals\r\n    }\r\n}\r\n\r\n\r\n//范围迭代器\r\nclass Range extends Iterator {\r\n\r\n    /*----------------------------------------\r\n    @class: 范围迭代器\r\n    @desc: 一种值线性变化的迭代器\r\n    @property: \r\n        * _start(number): 起始值\r\n        * _end(number): 终止值\r\n        * _step(number): 步长(速率)\r\n    @exp: \r\n        * new Range(1, 3) -> [1, 2, 3]\r\n        * Range.S(0, 4, 2) -> [0, 2, 4]\r\n        * Range.N(0, 5, 4) -> [0, 1.25, 2.5, 3.75, 5]\r\n    ----------------------------------------*/\r\n    constructor(start, end, step=1) {\r\n        super(start);\r\n        //起始值\r\n        this._start = start;\r\n        //终止值\r\n        this._end = end;\r\n        //步长\r\n        this._step = start<end ? Math.abs(step) : -Math.abs(step);\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 构建器\r\n    @desc: 根据\"步长\"构建迭代器\r\n    @params: \r\n        * step(number): 步长大小(速率)\r\n    @return(Range) \r\n    ----------------------------------------*/\r\n    static S(start, end, step=1) {\r\n        return new Range(start, end, step);\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 构建器\r\n    @desc: 根据\"迭代次数\"构建迭代器\r\n    @params: \r\n        * n(number): 迭代次数\r\n    @return(Range) \r\n    ----------------------------------------*/\r\n    static N(start, end, n) {\r\n        return new Range(start, end, (end-start)/n);\r\n    }\r\n\r\n    //值迭代逻辑\r\n    val() {\r\n        let val = this._val;\r\n        if(!this.end()) {\r\n            this._val += this._step;\r\n        } else {\r\n            this._val = this._end;\r\n        }\r\n        return val;\r\n    }\r\n\r\n    //停机状态\r\n    end() {\r\n        return (this._step>0) ? (this._val>this._end) : (this._val<this._end);\r\n    }\r\n\r\n    //复制\r\n    clone() {\r\n        return new Range(this._start, this._end, this._step);\r\n    }\r\n\r\n}\r\n\r\n\r\n//函数迭代器\r\nclass FuncIterator extends Iterator {\r\n\r\n    /*----------------------------------------\r\n    @class: 函数迭代器\r\n    @desc: 指定定义域范围(dod)和函数(fx)迭代生成对应的值域\r\n    @property: \r\n        * fx(function): 目标函数\r\n        * dod(Range|list): 定义域\r\n    @exp: \r\n        * new FuncIterator((x)=>{return x*x;}, Range.S(0, 3)) -> [0, 1, 4, 9]\r\n        * new FuncIterator((x)=>{return x*x;}, [0, 3])\r\n    ----------------------------------------*/\r\n    constructor(fx, dod) {\r\n        super();\r\n        //函数表达式\r\n        this.fx = fx;\r\n        //定义域(Range)\r\n        this.dod = dod.val ? dod : Range.S(...dod);\r\n    }\r\n    \r\n    val(toPoint=false) {\r\n        let x = this.dod.val();\r\n        return toPoint ? [x, this.fx(x)] : this.fx(x);\r\n    }\r\n\r\n    end() {\r\n        return this.dod.end();\r\n    }\r\n}\r\n\r\n\r\nmodule.exports.Iterator = Iterator;\r\nmodule.exports.Range = Range;\r\nmodule.exports.FuncIterator = FuncIterator;\n\n//# sourceURL=webpack://vision/./src/utils/iterator.js?");

/***/ }),

/***/ "./src/utils/random.js":
/*!*****************************!*\
  !*** ./src/utils/random.js ***!
  \*****************************/
/***/ ((module) => {

eval("/****************************************\r\n * Name: random\r\n * Date: 2022-08-01\r\n * Author: Ais\r\n * Project: Vision\r\n * Desc: \r\n * Version: 0.1\r\n****************************************/\r\n\r\n\r\n//随机选择器\r\nclass RandomSelector {\r\n\r\n    /*----------------------------------------\r\n    @class: RandomSelector(随机选择器)\r\n    @desc: 给定选项集，根据权重生成概率，随机选择一个选项。\r\n    @property: \r\n        * _ops(list:obj): 选项集\r\n    @method: \r\n        * _probability: 根据选项集中选项的权重计算概率\r\n        * select: 随机从选项集中选择一个选项\r\n    @exp:\r\n        * let rs = new RandomSelector([[\"a\", 1], [\"b\", 1], [\"c\", 3], [\"d\", 1]])\r\n    ----------------------------------------*/\r\n    constructor(options) {\r\n        //选项集\r\n        this._ops = this._probability(options);\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 计算概率\r\n    @desc: 基于权重计算概率 -> p[i] = wt[i] / sum(wt)\r\n    @params: \r\n        * options(list:list): [[op(选项, any), wt(权重, number:>0)]...]\r\n    @return(opt(list:obj)): [{\"op\": 选项, \"p\": 概率, \"ps/pe\": 概率范围}] \r\n    ----------------------------------------*/\r\n    _probability(options) {\r\n        //计算总权重\r\n        let swt = 0;\r\n        for(let i=0, n=options.length; i<n; i++) {\r\n            swt += options[i][1] || 0;\r\n        }\r\n        //计算每个选项的概率\r\n        let _ops = [], _ps = 0;\r\n        for(let i=0, n=options.length; i<n; i++) {\r\n            let p = (options[i][1] || 0) / swt;\r\n            _ops.push({\r\n                //选项\r\n                \"op\": options[i][0],\r\n                //概率\r\n                \"p\": p,\r\n                //概率范围\r\n                \"ps\": _ps, \"pe\": _ps + p\r\n            });\r\n            _ps += p;\r\n        }\r\n        return _ops;\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 随机选择\r\n    @desc: 从选项集中随机选择一个选项\r\n    @return(any) \r\n    ----------------------------------------*/\r\n    select() {\r\n        let r = Math.random();\r\n        for(let i=0, n=this._ops.length; i<n; i++) {\r\n            if(r > this._ops[i].ps && r <= this._ops[i].pe) {\r\n                return this._ops[i].op;\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\nmodule.exports.RandomSelector = RandomSelector;\r\n\n\n//# sourceURL=webpack://vision/./src/utils/random.js?");

/***/ }),

/***/ "./src/utils/tools.js":
/*!****************************!*\
  !*** ./src/utils/tools.js ***!
  \****************************/
/***/ ((module) => {

eval("/****************************************\r\n * Name: tool | 工具\r\n * Date: \r\n * Author: Ais\r\n * Project: Vision\r\n * Desc: 常用工具代码\r\n * Version: 0.1\r\n****************************************/\r\n\r\n\r\nclass Tools {\r\n\r\n    /*----------------------------------------\r\n    @func: regular polygon | 正多边形生成器\r\n    @desc: 并非严格意义上的正多边形，而是一种\"近似\"正多边形。\r\n    @params: \r\n        * n(number(N+, n>=3)): 边数\r\n        * r(number(r>0)): 半径\r\n        * po(list): 中心坐标\r\n        * rad(number): 起始弧度\r\n    @return(list)\r\n    @exp:\r\n        * Tools.regular_polygon(5, 100, [canvas.cx, canvas.cy]);\r\n    ----------------------------------------*/\r\n    static regular_polygon(n, r, po, rad=0) {\r\n        po = po || [0, 0];\r\n        let d_rad = (2*Math.PI)/n;\r\n        let ps = [];\r\n        for(let i=0; i<n; i++) {\r\n            ps.push([r*Math.cos(rad)+po[0], r*Math.sin(rad)+po[1]]);\r\n            rad += d_rad;\r\n        }\r\n        return ps;\r\n    }\r\n    static RP(n, r, po, rad=0) {\r\n        return Tools.regular_polygon(n, r, po, rad);\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 角度<>弧度 转换器\r\n    @desc: 在角度与弧度之间转换\r\n    @return(number)\r\n    @exp:\r\n        * Tools.ATR(45) -> Math.PI/4\r\n        * Tools.ATR(Math.PI) -> 45\r\n    ----------------------------------------*/\r\n    static ATR(angle) {\r\n        return (Math.PI/180)*angle;\r\n    }\r\n    static RTA(rad) {\r\n        return (180/Math.PI)*rad;\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 生成随机数\r\n    @params: \r\n        * start/end: 生成范围\r\n    @return(number)\r\n    @exp: \r\n        Tools.random(-5, 5)\r\n    ----------------------------------------*/\r\n    static random(start, end) {\r\n        return (end-start)*Math.random()+start;\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: (list)随机选择器\r\n    @desc: 从数组中随机选择一个元素\r\n    @params: \r\n        * ops(list): 选项集\r\n    @return(any)\r\n    @exp: \r\n        Tools.rslist([\"a\", \"b\", \"c\"])\r\n    ----------------------------------------*/\r\n    static rslist(ops) {\r\n        return ops[parseInt((ops.length)*Math.random())];\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: RGB(list) -> RGB(str)\r\n    @desc: 将RGB数组装换成RGB字符串\r\n    @params: \r\n        * color(list): 颜色数组\r\n    @exp: \r\n        Tools.RGB([255, 255, 255]) -> \"rgb(255, 255, 255, 1)\";\r\n    ----------------------------------------*/\r\n    static RGB(color) {\r\n        return `rgb(${color[0]||0}, ${color[1]||0}, ${color[2]||0}, ${color[3]||1})`;\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\nmodule.exports.Tools = Tools;\r\n\n\n//# sourceURL=webpack://vision/./src/utils/tools.js?");

/***/ }),

/***/ "./src/vector/area.js":
/*!****************************!*\
  !*** ./src/vector/area.js ***!
  \****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/****************************************\r\n * Name: 区域\r\n * Date: 2022-07-13\r\n * Author: Ais\r\n * Project: Vision\r\n * Desc: 描述一个封闭区域，并给定一个点是否在区域内的判定算法(in)\r\n * Version: 0.1\r\n * Update:\r\n *     [2022-07-14]: 增加区域反转功能, 将method(in)的判定反转 \r\n****************************************/\r\n\r\nconst Vector = (__webpack_require__(/*! ./vector.js */ \"./src/vector/vector.js\").Vector);\r\n\r\n\r\n//基类\r\nclass BaseArea {\r\n\r\n    /*----------------------------------------\r\n    @func: 判断一个给定坐标是否在区域内\r\n    @params:\r\n        * p(Vector||list): 坐标 -> Vector(x, y) || [x, y]\r\n    @return(bool) \r\n    ----------------------------------------*/\r\n    in(p) {\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\n//顶点集区域\r\nclass Area extends BaseArea {\r\n\r\n    /*----------------------------------------\r\n    @func: 顶点集区域\r\n    @desc: 通过一系列顶点坐标描述一个封闭区域\r\n    @property: \r\n        * vps(list:Vector): 构成区域的顶点集\r\n        * offset(number): 判定算法(in)的计算误差\r\n        * reverse(bool): 区域反转标记, 将method(in)的判定反转\r\n    ----------------------------------------*/\r\n    constructor(vpoints, reverse=false) {\r\n        super();\r\n        //顶点集\r\n        this.vps = vpoints;\r\n        //计算误差\r\n        this.offset = (Math.PI/180)*5;\r\n        //区域反转标记\r\n        this.reverse = reverse;\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 点是否在区域内的判定算法\r\n    @algorithm: \r\n        求解目标点(p)与区域的顶点集(vps)构成的凸多边形的内角和(rads),\r\n        当 rads == Math.PI*2 时，p在区域内部，反之不在。\r\n    @Waring: 该判定算法仅支持凸多边形\r\n    @params: \r\n        * p(Vector||list): 目标点\r\n    ----------------------------------------*/\r\n    in(p) {\r\n        p = p.v ? p : new Vector(...p);\r\n        //计算内角和\r\n        let rads = 0, n = this.vps.length;\r\n        for(let i=0; i<n; i++) {\r\n            let _rad = Math.abs(Vector.rad(Vector.sub(this.vps[i%n], p), Vector.sub(this.vps[(i+1)%n], p)))\r\n            rads += (_rad>Math.PI ? 2*Math.PI-_rad : _rad);\r\n        }\r\n        return this.reverse ^ (rads > Math.PI*2-this.offset) && (rads < Math.PI*2+this.offset) \r\n    }\r\n}\r\n\r\n\r\n//矩形区域\r\nclass RectArea extends BaseArea {\r\n\r\n    /*----------------------------------------\r\n    @func: 矩形区域\r\n    @desc: 通过分量范围来描述一个矩形区域(任意维)\r\n    @property: \r\n        * borders(list:list): 分量范围 \r\n    @exp:\r\n        new ReactArea([[100, 300], [100, 300]]) -> 中心点为(200, 200), 边长为100的矩形区域\r\n    ----------------------------------------*/\r\n    constructor(borders, reverse=false) {\r\n        super();\r\n        //矩形边界范围\r\n        this.borders = borders;\r\n        //区域反转标记\r\n        this.reverse = reverse;\r\n    }\r\n\r\n    in(p) {\r\n        p = p.v ? p : new Vector(...p);\r\n        for(let i=0, n=this.borders.length; i<n; i++) {\r\n            if((p.v[i] < this.borders[i][0]) || (p.v[i] > this.borders[i][1])) {\r\n                return this.reverse ^ false;\r\n            }\r\n        }\r\n        return this.reverse ^ true;\r\n    }\r\n}\r\n\r\n\r\n//圆形区域\r\nclass CircleArea extends BaseArea {\r\n\r\n    /*----------------------------------------\r\n    @func: 圆形区域\r\n    @desc: 描述一个圆形区域(任意维)\r\n    @property: \r\n        * po(Vector): 中心坐标\r\n        * r(number): 半径 \r\n    ----------------------------------------*/\r\n    constructor(po, r, reverse=false) {\r\n        super();\r\n        //中心坐标\r\n        this.po = po;\r\n        //半径\r\n        this.r = r;\r\n        //区域反转标记\r\n        this.reverse = reverse;\r\n    }\r\n\r\n    in(p) {\r\n        p = p.v ? p : new Vector(...p);\r\n        return this.reverse ^ (p.dist(this.po) < this.r);\r\n    }\r\n}\r\n\r\n\r\nmodule.exports.BaseArea = BaseArea;\r\nmodule.exports.Area = Area;\r\nmodule.exports.RectArea = RectArea;\r\nmodule.exports.CircleArea = CircleArea;\r\n\n\n//# sourceURL=webpack://vision/./src/vector/area.js?");

/***/ }),

/***/ "./src/vector/border.js":
/*!******************************!*\
  !*** ./src/vector/border.js ***!
  \******************************/
/***/ ((module) => {

eval("/****************************************\r\n * Name: 边界\r\n * Date: 2022-07-11\r\n * Author: Ais\r\n * Project: Vision\r\n * Desc: 对到达边界的粒子进行处理\r\n * Version: 0.1\r\n * Update:\r\n *     2022-07-27: 对limit()添加\"r\"(质心到边界的距离)参数，以支持在考虑粒子具有形状属性的情况下的限制作用\r\n****************************************/\r\n\r\n//边界限制器(基类)\r\nclass Border {\r\n\r\n    /*----------------------------------------\r\n    @func: 越界处理函数\r\n    @desc: 当目标发生越界时，通过该函数进行处理。\r\n    @params:\r\n        * p_obj(Particle): 目标粒子\r\n        * r(number): 形状半径\r\n    ----------------------------------------*/\r\n    limit(p_obj, r=0) {\r\n        return p_obj;\r\n    } \r\n}\r\n\r\n\r\n//矩形反射边界\r\nclass RectReflectBorder extends Border {\r\n\r\n    /*----------------------------------------\r\n    @func: 矩形反射边界\r\n    @desc: 当目标越界时，其垂直与反射面的速度分量将被反转，产生反射效果。\r\n    @property: \r\n        * borders(list): 边界范围 \r\n        * on_line(bool): 当该参数为true时，越界时会重置目标位置到边界线上\r\n    ----------------------------------------*/\r\n    constructor(borders, on_line=true) {\r\n        super();\r\n        //分量限制范围\r\n        this.borders = borders || [];\r\n        //边界线模式\r\n        this.on_line = on_line;\r\n    }\r\n\r\n    limit(p_obj, r=0) {\r\n        for(let i=0; i<this.borders.length; i++) {\r\n            if(p_obj.p.v[i]-r <= this.borders[i][0]) {\r\n                this.on_line ? p_obj.p.v[i] = this.borders[i][0]+r : null;\r\n                p_obj.v.v[i] = -p_obj.v.v[i];\r\n            }\r\n            if(p_obj.p.v[i]+r >= this.borders[i][1]) {\r\n                this.on_line ? p_obj.p.v[i] = this.borders[i][1]-r : null;\r\n                p_obj.v.v[i] = -p_obj.v.v[i];\r\n            }\r\n        }\r\n        return p_obj;\r\n    }\r\n}\r\n\r\n\r\n//矩形循环边界\r\nclass RectLoopBorder extends Border {\r\n\r\n    /*----------------------------------------\r\n    @func: 矩形循环边界\r\n    @desc: 当目标发生越界时，目标移动到当前边界的相对边界处。\r\n    @property: \r\n        * borders(list): 边界范围 \r\n    @exp:\r\n        RectLoopBorder([[0, 500], [0, 500]]);\r\n    ----------------------------------------*/\r\n    constructor(borders) {\r\n        super();\r\n        //分量限制范围\r\n        this.borders = borders || [];\r\n    }\r\n\r\n    limit(p_obj, r=0) {\r\n        for(let i=0; i<this.borders.length; i++) {\r\n            if(p_obj.p.v[i]-r <= this.borders[i][0]) {\r\n                p_obj.p._v[i] = this.borders[i][1]-r;\r\n            } else if(p_obj.p.v[i]+r >= this.borders[i][1]) {\r\n                p_obj.p._v[i] = this.borders[i][0]+r;\r\n            }\r\n        }\r\n        return p_obj;\r\n    }\r\n}\r\n\r\n\r\n//环形反射边界\r\nclass RingReflectBorder extends Border {\r\n\r\n    /*----------------------------------------\r\n    @class: 环形反射边界\r\n    @desc: 圆形边界，目标越界时进行速度反射\r\n    @property: \r\n        * po(Vector): 边界圆心坐标\r\n        * r(number,>0): 边界半径\r\n    ----------------------------------------*/\r\n    constructor(po, r) {\r\n        super();\r\n        //边界圆心坐标\r\n        this.po = po;\r\n        //边界半径\r\n        this.r = r;\r\n    }\r\n\r\n    limit(p_obj, r=0) {\r\n        if(this.po.dist(p_obj.p)+r > this.r) {\r\n            //反射面法向量\r\n            let rv = Vector.sub(this.po, p_obj.p).normalization();\r\n            //修正位置坐标\r\n            p_obj.p = Vector.add(this.po, rv.clone().mult(-(this.r-r)));\r\n            //反射速度向量\r\n            p_obj.v = Vector.sub(p_obj.v, rv.clone().mult(rv.dot(p_obj.v)*2))\r\n        }\r\n        return p_obj;\r\n    }\r\n}\r\n\r\n\r\n//环形循环边界\r\nclass RingLoopBorder extends Border {\r\n\r\n    /*----------------------------------------\r\n    @class: 环形循环边界\r\n    @desc: 圆形边界，目标越界时将其移动到目标与圆心坐标的对角位置\r\n    @property: \r\n        * po(Vector): 边界圆心坐标\r\n        * r(number,>0): 边界半径\r\n    ----------------------------------------*/\r\n    constructor(po, r) {\r\n        super();\r\n        //边界圆心坐标\r\n        this.po = po;\r\n        //边界半径\r\n        this.r = r;\r\n    }\r\n\r\n    limit(p_obj, r=0) {\r\n        if(this.po.dist(p_obj.p)+r > this.r) {\r\n            //反射面法向量\r\n            let rv = Vector.sub(this.po, p_obj.p).normalization();\r\n            //修正位置坐标(当前相对与圆心的对角位置)\r\n            p_obj.p = Vector.add(this.po, rv.clone().mult((this.r-r)));\r\n        }\r\n        return p_obj;\r\n    }\r\n}\r\n\r\n\r\n\r\nmodule.exports.Border = Border;\r\nmodule.exports.RectReflectBorder = RectReflectBorder;\r\nmodule.exports.RectLoopBorder = RectLoopBorder;\r\nmodule.exports.RingReflectBorder = RingReflectBorder;\r\nmodule.exports.RingLoopBorder = RingLoopBorder;\r\n\r\n\n\n//# sourceURL=webpack://vision/./src/vector/border.js?");

/***/ }),

/***/ "./src/vector/coor.js":
/*!****************************!*\
  !*** ./src/vector/coor.js ***!
  \****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/****************************************\r\n * Name: Coordinate System | 坐标系\r\n * Date: 2022-08-01\r\n * Author: Ais\r\n * Project: Vision\r\n * Desc: 构建坐标系, 对向量进行坐标变换\r\n * Version: 0.1\r\n****************************************/\r\n\r\nconst Vector = (__webpack_require__(/*! ./vector.js */ \"./src/vector/vector.js\").Vector);\r\n\r\n\r\n//坐标系(基类)\r\nclass CoordinateSystem {\r\n\r\n    /*----------------------------------------\r\n    @func: MCS(主坐标系) -> CS(当前坐标系)\r\n    @desc: 从主坐标系转换到当前坐标系\r\n    @params:\r\n        * vector(Vector): 目标向量\r\n    @return(Vector)\r\n    ----------------------------------------*/\r\n    to(vector) {\r\n        return vector;\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: CS -> MCS\r\n    @desc: 从当前坐标系转换到主坐标系\r\n    @params:\r\n        * vector(Vector): 目标向量\r\n    @return(Vector)\r\n    ----------------------------------------*/\r\n    from(vector) {\r\n        return vector;\r\n    }\r\n}\r\n\r\n\r\n//网格坐标系\r\nclass Grid extends CoordinateSystem {\r\n\r\n    /*----------------------------------------\r\n    @class: Grid(网格坐标系)\r\n    @desc: 构建网格坐标系\r\n    @property: \r\n        * co(vector): 坐标原点\r\n        * dx/dy(number): 网格单元尺寸\r\n        * RY(bool): y轴反转标记 -> true(向上) | false(向下)\r\n    @exp: \r\n    ----------------------------------------*/\r\n    constructor(co, dx, dy, RY=false) {\r\n        super();\r\n        //坐标原点\r\n        this.co = co;\r\n        //网格单元尺寸\r\n        this.dx = dx;\r\n        this.dy = dy;\r\n        //反转Y轴\r\n        this.RY = RY;\r\n    }\r\n\r\n    to(vector) {\r\n        let v = vector.clone().sub(this.co);\r\n        return new Vector(Math.round(v.x/this.dx), Math.round(v.y/this.dy)*(this.RY?-1:1))\r\n    }\r\n\r\n    from(vector) {\r\n        return new Vector(this.dx*vector.x, this.dy*vector.y*(this.RY?-1:1)).add(this.co);\r\n    }\r\n}\r\n\r\n\r\n//极坐标系\r\n\r\n\r\nmodule.exports.CoordinateSystem = CoordinateSystem;\r\nmodule.exports.Grid = Grid;\n\n//# sourceURL=webpack://vision/./src/vector/coor.js?");

/***/ }),

/***/ "./src/vector/field.js":
/*!*****************************!*\
  !*** ./src/vector/field.js ***!
  \*****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/****************************************\r\n * Name: Field | 矢量场\r\n * Date: 2022-07-13\r\n * Author: Ais\r\n * Project: Vision\r\n * Desc: 在给定区域内影响粒子行为\r\n * Version: 0.1\r\n****************************************/\r\n\r\nconst Vector = (__webpack_require__(/*! ./vector.js */ \"./src/vector/vector.js\").Vector);\r\nconst Area = __webpack_require__(/*! ./area.js */ \"./src/vector/area.js\");\r\n\r\n\r\n//矢量场(基类)\r\nclass Field {\r\n\r\n    /*----------------------------------------\r\n    @func: 矢量力场\r\n    @desc: 影响场范围内的粒子行为(对粒子进行力的作用)\r\n    @property: \r\n        * area(BaseArea): 场作用范围\r\n    ----------------------------------------*/\r\n    constructor(area) {\r\n        //场作用范围\r\n        this.area = area || new Area.BaseArea();\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 场作用力函数\r\n    @desc: 描述场对粒子的作用力\r\n    @params: \r\n        * fp(ForceParticle): 受力粒子\r\n    ----------------------------------------*/\r\n    force(fp) {}\r\n}\r\n\r\n\r\n//引力场\r\nclass Gravity extends Field {\r\n\r\n    //引力常数(6.67e-11|0.0000000000667)\r\n    static G = 0.01;\r\n\r\n    /*----------------------------------------\r\n    @func: 引力场\r\n    @desc: 模拟引力效果\r\n    @property: \r\n        * gp(Vector): 引力场中心质点坐标\r\n        * mass(number): 场心指点质量大小\r\n        * G(number): 引力常数, 当(G<0)时，表现为斥力\r\n        * area(Area): 引力场作用范围(默认为无限大)\r\n    ----------------------------------------*/\r\n    constructor(gp, mass=1) {\r\n        super();\r\n        //引力场中心坐标\r\n        this.gp = gp || new Vector(0, 0);\r\n        //场心质量\r\n        this.mass = mass;\r\n        //引力常数\r\n        this.G = Gravity.G;\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 引力作用\r\n    @desc: F = G * (m*M) / r^2\r\n    ----------------------------------------*/\r\n    force(fp) {\r\n        if(this.area.in(fp.p)) {\r\n            let r = this.gp.dist(fp.p);\r\n            let g = Vector.sub(this.gp, fp.p).norm(this.G * (this.mass * fp.mass) / r*r);\r\n            fp.force(g);\r\n        }\r\n    }\r\n\r\n    //计算两个粒子间的引力\r\n    static gravity(fp1, fp2) {\r\n        let r = Vector.dist(fp1.p, fp2.p);\r\n        let g = Gravity.G * (fp1.mass * fp2.mass) / r*r;\r\n        fp1.force(Vector.sub(fp2.p, fp1.p).norm(g));\r\n        fp2.force(Vector.sub(fp1.p, fp2.p).norm(g));\r\n    }\r\n}\r\n\r\n\r\n//匀加速场\r\nclass AccelerateField extends Field {\r\n\r\n    /*----------------------------------------\r\n    @class: 匀加速场\r\n    @desc: 对场内粒子施加固定力的作用\r\n    @property: \r\n        * A(vector): 加速度\r\n        * area(Area): 场作用范围\r\n    ----------------------------------------*/\r\n    constructor(A, area) {\r\n        super(area);\r\n        //加速度\r\n        this.A = A;\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 引力作用\r\n    @desc: F = A\r\n    ----------------------------------------*/\r\n    force(fp) {\r\n        fp.force(this.A);\r\n    }\r\n}\r\n\r\n\r\n//减速场\r\nclass DecelerateField extends Field {\r\n            \r\n    /*----------------------------------------\r\n    @class: 减速场\r\n    @desc: 对场内粒子施加减速作用\r\n    @property: \r\n        * _D(number): 减速系数\r\n        * area(Area): 场作用范围\r\n    ----------------------------------------*/\r\n    constructor(D, area) {\r\n        super(area);\r\n        //减速系数\r\n        this._D = -Math.abs(D || 0.015);\r\n    }\r\n\r\n    get D() { return this._D; }\r\n    set D(val) { this._D = -Math.abs(val); }\r\n    \r\n    /*----------------------------------------\r\n    @func: 减速作用\r\n    @desc: F = D * v\r\n    ----------------------------------------*/\r\n    force(fp) {\r\n        if(this.area.in(fp.p)) {\r\n            fp.force(fp.v.clone().norm(this.D * fp.v.norm() * fp.mass));\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n//偏转场\r\nclass DeflectField extends Field {\r\n\r\n    /*----------------------------------------\r\n    @class: 偏转场\r\n    @desc: 对场内粒子的速度产生偏转作用\r\n    @property: \r\n        * W(number): 偏转角速度(弧度), W>0(顺时针旋转) \r\n        * area(Area): 场作用范围\r\n    @exp: \r\n    ----------------------------------------*/\r\n    constructor(W, area) {\r\n        super(area);\r\n        //偏转角速度\r\n        this.W = W || 0.017;\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 偏转作用\r\n    @desc: v_val(线速度) = r(半径) * w(角速度)\r\n    ----------------------------------------*/\r\n    force(fp) {\r\n        if(this.area.in(fp.p)) {\r\n            fp.force(Vector.sub(fp.v.clone().rotate(this.W), fp.v));\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\nmodule.exports.Field = Field;\r\nmodule.exports.Gravity = Gravity;\r\nmodule.exports.AccelerateField = AccelerateField;\r\nmodule.exports.DecelerateField = DecelerateField;\r\nmodule.exports.DeflectField = DeflectField;\n\n//# sourceURL=webpack://vision/./src/vector/field.js?");

/***/ }),

/***/ "./src/vector/matrix.js":
/*!******************************!*\
  !*** ./src/vector/matrix.js ***!
  \******************************/
/***/ (() => {

eval("\n\n//# sourceURL=webpack://vision/./src/vector/matrix.js?");

/***/ }),

/***/ "./src/vector/particle.js":
/*!********************************!*\
  !*** ./src/vector/particle.js ***!
  \********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/****************************************\r\n * Name: 粒子系统/运动系统\r\n * Date: 2022-07-10\r\n * Author: Ais\r\n * Project: Vision\r\n * Desc: 通过向量描述粒子的运动\r\n * Version: 0.1\r\n****************************************/\r\n\r\nconst Vector = (__webpack_require__(/*! ./vector.js */ \"./src/vector/vector.js\").Vector);\r\n\r\n//粒子(基类)\r\nclass Particle {\r\n\r\n    /*----------------------------------------\r\n    @class: Particle(粒子)\r\n    @desc: 通过向量描述粒子的运动\r\n    @property: \r\n        * position(Vector): 位置矢量\r\n        * velocity(Vector): 速度矢量\r\n    @method:\r\n        * action(): 描述粒子运动模式 -> 粒子位置矢量(Vector)\r\n        * end(): 粒子停机状态 -> bool\r\n    @exp: \r\n        let p = new Particle(new Vector(100, 100), new Vector(2, 3));\r\n    ----------------------------------------*/\r\n    constructor(position, velocity) {\r\n        //位置矢量\r\n        this.p = position || new Vector(0, 0);\r\n        //速度矢量\r\n        this.v = velocity || new Vector(0, 0);\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 运动模式\r\n    @desc: 描述粒子的运动模式\r\n    @return(Vector): this.p -> 粒子的当前位置 \r\n    ----------------------------------------*/\r\n    action() {\r\n        return this.p.add(this.v);\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 停机状态\r\n    @desc: 描述粒子的停机状态\r\n    @return(bool):  \r\n    ----------------------------------------*/\r\n    end() {\r\n        return false;\r\n    }\r\n}\r\n\r\n\r\n//粒子系统(基类)\r\nclass ParticleSystem {\r\n\r\n    /*----------------------------------------\r\n    @class: ParticleSystem(粒子系统)\r\n    @desc: 描述粒子集群\r\n    @property: \r\n        * ps(list:Particle): 粒子容器\r\n        * tp_builder(function): 粒子生成器函数\r\n        * max_pn(number[N+]): 最大粒子数(>=0)\r\n        * gen_pn(number[N+]): 迭代过程粒子生成数\r\n        * GENR(bool): 粒子生成开关, 用于在迭代过程(action)中生成新的粒子\r\n        * DSTR(bool): 粒子销毁开关, 当容器中的粒子进入停机状态时，从容器中移除该粒子\r\n        * _END(bool): 粒子系统停机状态\r\n    @method:\r\n        * init(): 对粒子系统进行初始化\r\n        * build(): 生成新的粒子\r\n        * action(): 描述粒子集群的行为模式\r\n        * end(): 返回粒子系统的停机状态\r\n    @exp: \r\n        let ptcs = new ParticleSystem().init();\r\n    ----------------------------------------*/\r\n    constructor() {\r\n        //粒子容器\r\n        this.ps = [];\r\n        //粒子生成器\r\n        this.tp_builder = null;\r\n        //最大粒子数\r\n        this.max_pn = Infinity;\r\n        //迭代过程粒子生成数\r\n        this.gen_pn = 1;\r\n        //粒子生成开关\r\n        this.GENR = false;\r\n        //粒子销毁开关\r\n        this.DSTR = true;\r\n        //粒子系统停机标记\r\n        this._END = false;\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 构建器\r\n    @desc: 通过 tp_builder 构建粒子群\r\n    @params: \r\n        * tp_builder(function): 粒子生成器函数\r\n    @return(ParticleSystem)\r\n    @exp: \r\n        ParticleSystem.Builder(()=>{\r\n            return new Particle();\r\n        })\r\n    ----------------------------------------*/\r\n    static Builder(tp_builder) {\r\n        let ps = new ParticleSystem();\r\n        ps.tp_builder = tp_builder;\r\n        return ps;\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 初始化\r\n    @desc: 对粒子系统进行初始化\r\n    @return(this) \r\n    ----------------------------------------*/\r\n    init(n=0) {\r\n        this.ps = [];\r\n        for(let i=0; i<n; i++) { this.build(); }\r\n        return this;\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 构建器\r\n    @desc: 生成新的粒子，并添加到容器中\r\n    @warning: 在重新该方法时，需要注意尽量不添加形参，这是由于当\r\n    this.GENR = true 时，会在action调用 this.build() 来构建新粒子\r\n    ----------------------------------------*/\r\n    build() {\r\n        if(this.ps.length < this.max_pn) {\r\n            this.tp_builder && this.ps.push(this.tp_builder());\r\n        }\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 行为模式(迭代过程)\r\n    @desc: 描述粒子集群的行为模式\r\n    ----------------------------------------*/\r\n    action() {\r\n        let _ps = [], _END = true;\r\n        for(let i=0, n=this.ps.length; i<n; i++) {\r\n            //判断粒子的停机状态\r\n            let isEND = this.ps[i].end(); _END = isEND && _END;\r\n            if(!isEND) {\r\n                //调用粒子的行为模式方法\r\n                this.ps[i].action(); _ps.push(this.ps[i]);\r\n            } else {\r\n                //根据\"粒子销毁开关\"判断是否销毁停机粒子\r\n                (this.DSTR == false) && _ps.push(this.ps[i]);\r\n            }\r\n        }\r\n        //更新粒子容器和停机状态标记\r\n        this.ps = _ps; this._END = _END;\r\n        //生成新的粒子\r\n        if(this.GENR) {\r\n            for(let i=0, n=this.gen_pn; i<n; i++) {\r\n                this.build();\r\n            }\r\n        }\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 停机状态\r\n    @desc: 返回粒子系统的停机状态\r\n    ----------------------------------------*/\r\n    end() {\r\n        return this._END;\r\n    }\r\n}\r\n\r\n\r\n//力粒子\r\nclass ForceParticle extends Particle {\r\n\r\n    /*----------------------------------------\r\n    @func: 可受力粒子\r\n    @property: \r\n        * ps(Vector): 起始位置\r\n        * pe(Vector): 终止位置\r\n        * v_rate(number): 速率(this.v.norm())\r\n    ----------------------------------------*/\r\n    constructor(position, velocity, acceleration, mass) {\r\n        super();\r\n        //位置矢量\r\n        this.p = position || new Vector(0, 0);\r\n        //速度矢量\r\n        this.v = velocity || new Vector(0, 0);\r\n        //加速度\r\n        this.acc = acceleration || new Vector(0, 0);\r\n        //质量\r\n        this.mass = mass || 1;\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 受力(积累效应)\r\n    @desc: 通过受力来改变粒子的加速度\r\n    @params: \r\n        * f(Vector): 作用力\r\n    ----------------------------------------*/\r\n    force(f) {\r\n        this.acc.add(f.clone().mult(1/this.mass));\r\n    }\r\n\r\n    action() {\r\n        this.p.add(this.v.add(this.acc));\r\n        this.acc = new Vector(0, 0);\r\n        return this.p;\r\n    }\r\n}\r\n\r\n\r\n//线性运动粒子\r\nclass LinearMotorParticle extends Particle {\r\n\r\n    /*----------------------------------------\r\n    @func: 线性运动\r\n    @desc: 描述直线运动模式的粒子\r\n    @property: \r\n        * ps(Vector): 起始位置\r\n        * pe(Vector): 终止位置\r\n        * v_rate(number): 速率(this.v.norm())\r\n    ----------------------------------------*/\r\n    constructor(ps, pe, v_rate=1) {\r\n        super();\r\n        //起始位置\r\n        this._ps = ps;\r\n        //终止位置\r\n        this._pe = pe;\r\n        //当前位置\r\n        this.p = this._ps.clone();\r\n        //速度\r\n        this.v = Vector.sub(this._pe, this._ps).norm(Math.abs(v_rate));\r\n        /*  \r\n        运动模式:\r\n            * [line]: 移动到pe后停机\r\n            * [loop]: 移动到pe后回到ps\r\n            * [back]: 移动到pe后，ps与pe互换\r\n        */\r\n        this.mode = \"line\";\r\n        //终止距离误差倍率(用于终点距离的判断: end_dist <= this.v.norm() * this.end_dist_rate)\r\n        this.end_dist_rate = 1.2;\r\n    }\r\n    \r\n    get ps() { return this._ps.clone(); }\r\n    get pe() { return this._pe.clone(); }\r\n    \r\n    //设置终止位置(并重新计算速度方向)\r\n    set pe(vector) {\r\n        this._pe = vector.clone();\r\n        this.v = Vector.sub(this._pe, this.p).norm(this.v.norm());\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 设置速率\r\n    @desc: \r\n        * v_rate: 速度矢量的模长, 每次迭代移动的像素大小\r\n        * v_count: 经过多少次迭代后移动到pe\r\n    @params: \r\n        * val(number): 速率\r\n    @exp: \r\n        p.v_rate = 5;\r\n        p.v_count = 300;\r\n    ----------------------------------------*/\r\n    set v_rate(val) { this.v.norm(val); }\r\n    set v_count(val) { this.v.norm(Vector.dist(this._pe, this._ps) / val); }\r\n\r\n    /*----------------------------------------\r\n    @func: 停机状态\r\n    @desc: 描述粒子在什么条件下停机(停止运动)\r\n    @return(bool): 状态\r\n    ----------------------------------------*/\r\n    end() {\r\n        return this.p.dist(this._pe) <= this.v.norm() * this.end_dist_rate;\r\n    }\r\n\r\n    //运动模式\r\n    action() {\r\n        if(!this.end()) {\r\n            this.p.add(this.v);\r\n        } else {\r\n            switch(this.mode){\r\n                case \"loop\": {\r\n                    this.p = this._ps.clone();\r\n                    break;\r\n                }\r\n                case \"back\": {\r\n                    this.p = this._pe.clone();\r\n                    this._pe = this._ps.clone();\r\n                    this._ps = this.p.clone();\r\n                    this.v.mult(-1);\r\n                    break;\r\n                }\r\n                default: {\r\n                    this.p = this._pe.clone();\r\n                }\r\n            }\r\n        }\r\n        return this.p;\r\n    }\r\n}\r\n\r\n\r\n//环形运动系统\r\nclass CircularMotorParticle extends Particle {\r\n\r\n    /*----------------------------------------\r\n    @func: 环形运动\r\n    @desc: 描述圆形运动模式的粒子\r\n    @property: \r\n        * o(Vector): 圆心位置\r\n        * r(number): 旋转半径\r\n        * v_rad(number): 旋转速率(弧度)\r\n        * rad(number): 起始弧度\r\n    ----------------------------------------*/\r\n    constructor(o, r, v_rad, rad=0) {\r\n        super();\r\n        //圆心位置\r\n        this.o = o || new Vector(0, 0);\r\n        //旋转半径\r\n        this.r = r || 1;\r\n        //速率\r\n        this.v_rad = v_rad || (Math.PI/180);\r\n        //当前弧度(-2*PI, 2*PI)\r\n        this.rad = rad;\r\n        //当前坐标(以this.o为原点)\r\n        this.po = new Vector(this.r*Math.sin(this.rad), this.r*Math.cos(this.rad));\r\n        //当前坐标(以(0, 0)为原点)\r\n        this.p = Vector.add(this.po, this.o);\r\n    }\r\n\r\n    //运动模式\r\n    action() {\r\n        this._p = this.p.clone();\r\n        this.rad += this.v_rad;\r\n        if(this.rad >= 2 * Math.PI) { this.rad -= 2 * Math.PI; } \r\n        if(this.rad <= -2 * Math.PI) { this.rad += 2 * Math.PI; } \r\n        this.po.x = this.r * Math.sin(this.rad);\r\n        this.po.y = this.r * Math.cos(this.rad);\r\n        this.p = Vector.add(this.po, this.o);\r\n        this.v = this.p.clone().sub(this._p);\r\n        return this.p;\r\n    }\r\n\r\n}\r\n\r\n\r\n//随机游走器\r\nclass RandomWalkerParticle extends Particle {\r\n    \r\n    /*----------------------------------------\r\n    @func: 随机游走\r\n    @desc: 给定一组速度向量集，每次随机选择一个速度进行移动\r\n    @property: \r\n        * ps(Vector): 初始位置\r\n        * rvs(list): 随机速度向量集 -> [Vector(速度向量), wt(权重)]\r\n    ----------------------------------------*/\r\n    constructor(ps, rvs) {\r\n        super();\r\n        //初始位置\r\n        this.p = ps;\r\n        //随机速度向量集\r\n        this._rvs = this._probability(rvs);\r\n    }\r\n\r\n    //计算概率(基于权重): p[i] = wt[i] / sum(wt)\r\n    _probability(rvs) {\r\n        //计算总权重\r\n        let swt = 0;\r\n        for(let i=0, end=rvs.length; i<end; i++) {\r\n            swt += rvs[i][1];\r\n        }\r\n        //计算每个速度矢量的概率\r\n        let _rvs = [], _ps = 0;\r\n        for(let i=0, end=rvs.length; i<end; i++) {\r\n            let p = (rvs[i][1] || 0) / swt;\r\n            _rvs.push({\r\n                //速度\r\n                \"v\": rvs[i][0] || new Vector(0, 0),\r\n                //概率\r\n                \"p\": p,\r\n                //概率范围\r\n                \"ps\": _ps, \"pe\": _ps + p\r\n            });\r\n            _ps += p;\r\n        }\r\n        return _rvs;\r\n    }\r\n\r\n    //随机选择速度\r\n    rv_select() {\r\n        let r = Math.random();\r\n        for(let i=0, end=this._rvs.length; i<end; i++) {\r\n            if(r > this._rvs[i].ps && r <= this._rvs[i].pe) {\r\n                return this._rvs[i].v;\r\n            }\r\n        }\r\n    }\r\n\r\n    //运动模式\r\n    action() {\r\n        //选择随机速度\r\n        this.v = this.rv_select();\r\n        return this.p.add(this.v);\r\n    }\r\n}\r\n\r\n\r\n\r\nmodule.exports.Particle = Particle;\r\nmodule.exports.ParticleSystem = ParticleSystem;\r\nmodule.exports.ForceParticle = ForceParticle;\r\nmodule.exports.LinearMotorParticle = LinearMotorParticle;\r\nmodule.exports.CircularMotorParticle = CircularMotorParticle;\r\nmodule.exports.RandomWalkerParticle = RandomWalkerParticle;\n\n//# sourceURL=webpack://vision/./src/vector/particle.js?");

/***/ }),

/***/ "./src/vector/tracker.js":
/*!*******************************!*\
  !*** ./src/vector/tracker.js ***!
  \*******************************/
/***/ ((module) => {

eval("/****************************************\r\n * Name: 轨迹追踪器\r\n * Date: 2022-07-15\r\n * Author: Ais\r\n * Project: Vision\r\n * Desc: 追踪记录目标粒子的移动轨迹\r\n * Version: 0.1\r\n****************************************/\r\n\r\nclass TrailTracker {\r\n\r\n    /*----------------------------------------\r\n    @func: 轨迹追踪器\r\n    @desc: 隐式地追踪记录目标粒子的移动轨迹\r\n    @property: \r\n        * tp(Particle): 目标粒子\r\n        * tn(number): 轨迹长度\r\n        * trail(list:Vector): 轨迹向量容器\r\n    @method:\r\n        * _bind(): 绑定追踪的粒子对象\r\n    ----------------------------------------*/\r\n    constructor(tp, tn=10) {\r\n        //目标粒子\r\n        this.tp = tp;\r\n        //轨迹长度\r\n        this.tn = tn;\r\n        //轨迹\r\n        this.trail = [];\r\n        //绑定目标对象\r\n        this._bind();\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 绑定追踪的粒子对象\r\n    @desc: 通过hook目标对象的action()方法来实现隐式的轨迹追踪效果\r\n    ----------------------------------------*/\r\n    _bind() {\r\n        this.trail = [this.tp.p.clone()];\r\n        //hook目标对象的action方法\r\n        let _this = this;\r\n        this.tp._tracker_hook_action = this.tp.action;\r\n        this.tp.action = function() {\r\n            let p = this._tracker_hook_action(...arguments);\r\n            (_this.trail.length >= _this.tn) && _this.trail.shift();\r\n            _this.trail.push(p.clone());\r\n            return p;\r\n        }\r\n    }\r\n}\r\n\r\n\r\nmodule.exports.TrailTracker = TrailTracker;\n\n//# sourceURL=webpack://vision/./src/vector/tracker.js?");

/***/ }),

/***/ "./src/vector/vector.js":
/*!******************************!*\
  !*** ./src/vector/vector.js ***!
  \******************************/
/***/ ((module) => {

eval("/****************************************\r\n * Name: Vector | 向量系统\r\n * Date: 2022-06-20\r\n * Author: Ais\r\n * Project: Vision\r\n * Desc: Vision框架核心组件\r\n * Version: 0.1\r\n****************************************/\r\n\r\nclass Vector {\r\n\r\n    /*----------------------------------------\r\n    @func: Vector构建器\r\n    @desc: 通过函数参数作为向量分量构建向量，默认构建(0, 0)的二维向量\r\n    @return(Vector): obj(Vector)\r\n    @exp: \r\n        v = new Vector(1, 2, 3) -> v(1, 2, 3)\r\n    ----------------------------------------*/\r\n    constructor(...v) {\r\n        //向量分量\r\n        this._v = v.length > 0 ? [...v] : [0, 0];\r\n    }\r\n\r\n    //static builder\r\n    static V(...v) {\r\n        return new Vector(...v);\r\n    }\r\n    static v(...v) {\r\n        return new Vector(...v);\r\n    }\r\n\r\n    //builder -> v(1, 1, 1, ...)\r\n    static ones(dim=2) {\r\n        return new Vector(...Array(dim).fill(1))\r\n    }\r\n\r\n    //builder -> v(0, 0, 0, ...)\r\n    static zeros(dim=2) {\r\n        return new Vector(...Array(dim).fill(0))\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: builder -> 生成随机向量\r\n    @desc: 生成指定范围内的随机向量\r\n    @params: \r\n        * range(list): 向量分量范围, 其长度决定了向量的维度\r\n        * isint(false): 分量值类型 true(int) | false(float)\r\n    @return(Vector): Vector(obj)\r\n    @exp: \r\n        Vector.random([[1, 3], [1, 3]]) -> v(1.13, 2.54)\r\n        Vector.random([[1, 3], [1, 3]], true) -> v(1, 2)\r\n        Vector.random([[1, 3], [1, 3], [4, 7]]) -> v(2.13, 0.54, 5.56)\r\n    ----------------------------------------*/\r\n    static random(range=[], isint=false) {\r\n        let v = [], r = 0;\r\n        for(let i=0, end=range.length; i<end; i++){\r\n            r = Math.random() * (range[i][1] - range[i][0]) + range[i][0];\r\n            isint ? v.push(parseInt(r)) : v.push(r);\r\n        }\r\n        return new Vector(...v);\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: builder -> 生成随机二维向量\r\n    @desc: 生成一个圆范围内的随机向量\r\n    @params: \r\n        * sR/eR(number:>0): 向量模长范围\r\n    @return(Vector)\r\n    @exp: \r\n        Vector.rcv(300) -> 向量模长为300, 方向随机\r\n        Vector.rcv(100, 300) -> 向量模长范围为(100, 300), 方向随机\r\n    ----------------------------------------*/\r\n    static rcv(sR, eR=null) {\r\n        let rad = Math.random() * (Math.PI * 2);\r\n        let r = (eR == null ? Math.random()*sR : Math.random()*(eR-sR)+sR);\r\n        return new Vector(Math.cos(rad)*r, Math.sin(rad)*r);\r\n    }\r\n\r\n    //分量接口\r\n    get v() { return this._v; }\r\n    get x(){ return this._v[0]; }\r\n    get y(){ return this._v[1]; }\r\n    get z(){ return this._v[2]; }\r\n    set x(val){ this._v[0] = val; }\r\n    set y(val){ this._v[1] = val; }\r\n    set z(val){ this._v[2] = val; }\r\n\r\n    /*----------------------------------------\r\n    @func: 加法\r\n    @desc: 向量的对应分量相加\r\n    @params: \r\n        * vector(Vector): 操作数\r\n    @return(Vector): this\r\n    @exp: \r\n        1. 维数相同的情况\r\n        let v1 = new Vector(1, 2, 3);\r\n        let v2 = new Vector(4, 5, 6);\r\n        v1.add(v2) -> v(5, 7, 9) -> v1\r\n        2. 维数不同的情况\r\n        let v1 = new Vector(1, 2, 3);\r\n        * v1.add(new Vector(1, 2, 3, 4, 5)) -> v(2, 4, 6) -> v1\r\n        * v1.add(new Vector(1, 2)) -> v(2, 4, 3) -> v1\r\n    ----------------------------------------*/\r\n    add(vector){\r\n        let v = vector.v;\r\n        for(let i=0, end=this._v.length; i<end; i++) {\r\n            this._v[i] += (v[i] || 0);\r\n        }\r\n        return this;\r\n    }\r\n    static add(...vector) {\r\n        let v = Vector.zeros(vector[0].dim());\r\n        for(let i=0, end=vector.length; i<end; i++) {\r\n            v.dim()<vector[i].dim() && v.dim(vector[i].dim())\r\n            v.add(vector[i]);\r\n        }\r\n        return v;\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 标量乘法\r\n    @desc: 数k乘以向量的每个分量\r\n    @params: \r\n        * k(int/float): 操作数\r\n    @return(Vector): this \r\n    @exp: \r\n        let v1 = new Vector(1, 2, 3);\r\n        v1.mult(2) -> v(2, 4, 6) -> v1\r\n    ----------------------------------------*/\r\n    mult(k) {\r\n        for(let i=0, end=this._v.length; i<end; i++) {\r\n            this._v[i] *= k;\r\n        }\r\n        return this;\r\n    }\r\n    static mult(vector, k) {\r\n        return vector.clone().mult(k);\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 减法\r\n    @desc: 加法的一种特殊情况\r\n    @params: \r\n        * vector(Vector): 操作数\r\n    @return(Vector): this \r\n    ----------------------------------------*/\r\n    sub(vector){\r\n        //向量方法实现\r\n        // return this.add(vector.clone().mult(-1));\r\n        //计算优化实现\r\n        let v = vector.v;\r\n        for(let i=0, end=this._v.length; i<end; i++) {\r\n            this._v[i] -= (v[i] || 0);\r\n        }\r\n        return this;\r\n    }\r\n    static sub(...vector) {\r\n        let v = vector[0].clone();\r\n        for(let i=1, end=vector.length; i<end; i++) {\r\n            v.sub(vector[i]);\r\n        }\r\n        return v;\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: dot product | 标量积(点积)\r\n    @desc: v1·v2 -> sum(v1[i]*v2[i]) -> |v1|*|v2|*cos(rad)\r\n    @params: \r\n        * vector(Vector): 操作数\r\n    @return(float)\r\n    ----------------------------------------*/\r\n    dot(vector) {\r\n        let t = 0, v = vector.v;\r\n        for(let i=0, end=this._v.length; i<end; i++) {\r\n            t += this._v[i] * (v[i] || 0);\r\n        }\r\n        return t;\r\n    }\r\n    inner(vector) {\r\n        return this.dot(vector);\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: Linear Combination | 线性组合\r\n    @desc: lc = v1*w[1] + v2*w[2] + ... + vn*w[n]\r\n    @params: \r\n        * vectors(list:Vector): 向量组\r\n        * w(list:number): 权\r\n    @condition: vectors[i].dim() == w.length\r\n    @return(Vector)\r\n    @ exp:\r\n        LC([\r\n            new Vector(1, 1),\r\n            new Vector(2, 2),\r\n            new Vector(3, 3),\r\n        ], [6, 3, 2]) -> Vector(18, 18)\r\n    ----------------------------------------*/\r\n    static LC(vectors, w) {\r\n        let v = Vector.zeros(vectors[0].dim());\r\n        for(let i=0, n=vectors.length; i<n; i++) {\r\n            v.add(vectors[i].clone().mult(w[i]));\r\n        }\r\n        return v;\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: Linear Mapping | 线性映射\r\n    @desc: 对向量进行线性变换，有以下两种实现方式\r\n        * 行向量: 设 vi 为 m[i] 构成的行向量,\r\n        则 LM(m) -> o.add(v.dot(vi)), 即 v 与 vi 的点积之和\r\n        * 列向量: 设 vk 为 m[i][k=(1, 2, 3...)] 的列向量\r\n        则 LM(m) -> LC(vk, v), 即以 v 的分量为权，对m的列向量的线性组合\r\n    @params: \r\n        * m(list:list): 矩阵(数组形式)\r\n    @return(Vector)\r\n    ----------------------------------------*/\r\n    LM(m) {\r\n        let _v = [];\r\n        for(let i=0, endi=m.length; i<endi; i++) {\r\n            //[Vector]: _v.push(this.dot(new Vector(...m[i])));\r\n            let _vi = 0;\r\n            for(let k=0, endk=m[i].length; k<endk; k++) {\r\n                _vi += m[i][k] * (this._v[k] || 0);\r\n            }\r\n            _v.push(_vi);\r\n        }\r\n        this._v = _v;\r\n        return this;\r\n    }\r\n    static LM(vector, m) {\r\n        return vector.clone().map(m);\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 线性插值\r\n    @desc: v(t) = (1-t)*v1 + t*v2 -> v1 + t*(v2-v1)\r\n    @params: \r\n        * vector(Vector): 目标向量\r\n        * t(float): 0<=t<=1 \r\n    @return(Vector)\r\n    ----------------------------------------*/\r\n    lerp(vector, t) {\r\n        return (t>0 && t<1) ? vector.clone().sub(this).mult(t).add(this) : (t<=0 ? this.clone() : vector.clone());\r\n    }\r\n    static lerp(v_from, v_to, t) {\r\n        return v_from.lerp(v_to, t);\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 二维向量的旋转变换\r\n    @desc: 对向量(dim=2)进行旋转(线性变换)\r\n    @params: \r\n        * rad(number): 旋转角度\r\n        * angle(bool): rad参数格式 -> true(弧度) | false(角度)\r\n    @return(Vector)\r\n    @exp:\r\n        * v.rotate(Math.PI/4)\r\n        * v.rotate(45, true)\r\n    ----------------------------------------*/\r\n    rotate(rad, angle=false) {\r\n        /* \r\n        [Vector]:\r\n        this._v = this.LM([\r\n            [Math.cos(rad), -Math.sin(rad)],\r\n            [Math.sin(rad), Math.cos(rad)],\r\n        ])\r\n        */\r\n        rad = angle ? (Math.PI/180*rad) : rad;\r\n        let cos_rad = Math.cos(rad), sin_rad = Math.sin(rad);\r\n        let x = this._v[0] * cos_rad - this._v[1] * sin_rad;\r\n        let y = this._v[0] * sin_rad + this._v[1] * cos_rad;\r\n        this._v[0] = x, this._v[1] = y;\r\n        return this;\r\n    }\r\n    static rotate(vector, rad) {\r\n        return vector.clone().rotate(rad);\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 维度(分量数)(get/set)\r\n    @desc: get/set\r\n    @params: \r\n        * n(int): 新的维度\r\n    @return(int): 向量的维度(分量数)\r\n        * v.dim() -> int\r\n        * v.dim(3) -> this\r\n    @exp:\r\n        let v = new Vector([1, 1, 2, 7])\r\n        v.dim() -> 4\r\n        v.dim(3) -> v(1, 1, 2) -> v\r\n        v.dim(5) -> v(1, 1, 2, 7, 0) -> v\r\n    ----------------------------------------*/\r\n    dim(n=null) {\r\n        if(n!=null) {\r\n            let v = [], _n = parseInt(n);\r\n            for(let i=0; i<_n; i++) {\r\n                v[i] = this.v[i] || 0;\r\n            }\r\n            this._v = v;\r\n            return this;\r\n        } else {\r\n            return this._v.length;\r\n        }\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 模(get/set)\r\n    @desc: 向量的模长\r\n    @params: \r\n        * n(int/float): 设置的模长\r\n    @return(float): 向量的模长\r\n        * v.norm() -> float\r\n        * v.norm(3) -> this\r\n    ----------------------------------------*/\r\n    norm(n=null) {\r\n        //计算模长\r\n        let t = 0;\r\n        for(let i=0, end=this._v.length; i<end; i++) {\r\n            t += this._v[i] * this._v[i];\r\n        }\r\n        let v_norm = Math.sqrt(t);\r\n        //设置模长\r\n        (n!=null) && (v_norm != 0) && this.mult(n/v_norm);\r\n        return (n==null) ? v_norm : this;\r\n    }\r\n\r\n    //单位化\r\n    normalization() {\r\n        let _norm = this.norm();\r\n        (_norm != 0) && this.mult(1/_norm);\r\n        return this;\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 限制器\r\n    @desc: 限制向量的模长, 当模长超过边界值的时候，设置模长为邻近的边界值\r\n    @params: \r\n        * max(int/float): 最大值边界\r\n        * min(int/float): 最小值边界\r\n    @return(Vector): this\r\n    @exp:\r\n        v.limit(5) -> (0 < v.norm() <5)\r\n        v.limit(2, 5) -> (2 < v.norm() <=5)\r\n    ----------------------------------------*/\r\n    limit(max, min=null) {\r\n        let _max, _min, _norm = this.norm();\r\n        if(min == null){_min=0, _max=Math.abs(max);} else {_min=Math.abs(max), _max=Math.abs(min);}\r\n        (_norm>=_min && _norm<=_max) ? null : this.norm(_norm>_max ? _max : _min);\r\n        return this;\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 克隆/复制\r\n    @desc: 复制向量\r\n    @return(Vector)\r\n    ----------------------------------------*/\r\n    clone() {\r\n        return new Vector(...this._v);\r\n    }\r\n    copy() {\r\n        return this.clone();\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 计算欧式距离\r\n    @desc: 计算两个向量之间的欧式距离(坐标视角)\r\n    @params: \r\n        * vector(Vector): 目标向量\r\n    @return(float): 距离\r\n    @exp: \r\n        v1.dist(v2) -> v1与v2的距离\r\n        v1.dist() -> v1到原点的距离(v.norm())\r\n    ----------------------------------------*/\r\n    dist(vector=null) {\r\n        //向量法实现\r\n        // return this.clone().sub(vector).norm();\r\n        //计算优化\r\n        if(vector == null) {\r\n            return this.norm();\r\n        } else {\r\n            let t = 0, v = vector.v;\r\n            for(let i=0, end=this._v.length; i<end; i++) {\r\n                t += (this._v[i] - v[i]) * (this._v[i] - v[i]);\r\n            }\r\n            return Math.sqrt(t);\r\n        }\r\n    }\r\n    static dist(v1, v2) {\r\n        return v1.dist(v2);\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 计算弧度(dim()==2)\r\n    @desc: 计算两个向量之间的弧度差(极坐标视角)\r\n    @params: \r\n        * vector(Vector): 目标向量\r\n    @return(float): 弧度差\r\n    @exp: \r\n        v1.rad(v2) -> v1与v2的弧度差\r\n        v1.rad() -> v1与x轴正方向的弧度差\r\n    ----------------------------------------*/\r\n    rad(vector=null) {\r\n        let x = this._v[0], y = this._v[1];\r\n        let rad = Math.atan(y/x);\r\n        rad = (x>=0) ? (y >= 0 ? rad : Math.PI*2 + rad) : (Math.PI + rad);\r\n        return  vector ? rad - vector.rad() : rad;\r\n    }\r\n    static rad(v1, v2) {\r\n        return v1.rad(v2);\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 整数化\r\n    @desc: 将分量转换成整数\r\n    ----------------------------------------*/\r\n    toint() {\r\n        for(let i=0, end=this._v.length; i<end; i++) { this._v[i] = parseInt(this._v[i]);}\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 向量分量范围判断\r\n    @desc: 判断向量的分量是否在指定范围\r\n    @params: \r\n        * range(list): 分量范围\r\n    @return(bool): 判定结果 \r\n    @exp: \r\n        new Vector(1, 2).in([[1, 5], [1, 5]]) -> true\r\n        new Vector(1, 2).in([[1, 5], [0, 1]]) -> false\r\n    ----------------------------------------*/\r\n    in(range=[]) {\r\n        for(let i=0, end=range.length; i<end; i++) {\r\n            if(!(this._v[i] >= range[i][0] && this._v[i] <= range[i][1])) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    static in(vector, range) {\r\n        return vector.in(range);\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 从坐标数组中构建向量\r\n    @desc: [[x1, y1], [x2, y2], ..., [xn, yn]] -> [v1, v2, ..., vn]\r\n    @params: \r\n        * ps(list:list): 坐标点的数组形式\r\n    @return(list:Vector): 坐标点的向量形式 \r\n    @exp: \r\n        Vector.vpoints([[100, 100], [200, 200]]) -> [Vector(100, 100), Vector(200, 200)]\r\n    ----------------------------------------*/\r\n    static vpoints(ps) {\r\n        let vps = [];\r\n        for(let i=0, n=ps.length; i<n; i++) {\r\n            vps.push(new Vector(...ps[i]));\r\n        }\r\n        return vps;\r\n    }\r\n\r\n}\r\n\r\n\r\nmodule.exports.Vector = Vector;\r\n\r\n\n\n//# sourceURL=webpack://vision/./src/vector/vector.js?");

/***/ }),

/***/ "./src/views/capturer.js":
/*!*******************************!*\
  !*** ./src/views/capturer.js ***!
  \*******************************/
/***/ ((module) => {

eval("/****************************************\r\n * Name: capturer | 截图器\r\n * Date: 2022-09-06\r\n * Author: Ais\r\n * Project: Vision\r\n * Desc: 截取Canvas图像后导出\r\n * Version: 0.1\r\n****************************************/\r\n\r\n\r\n//截图器\r\nclass Capturer {\r\n\r\n    /*----------------------------------------\r\n    @class: 截图器\r\n    @desc: 捕获canvas图像\r\n    @property: \r\n        * canvasObj(Canvas): canvas对象\r\n        * fileTitle(str): 导出文件标题\r\n        * fn(number:>0): 导出文件计数器\r\n        * _capture_keyCode(ascii-number): 截图按键值\r\n    @method: \r\n        * capture: 截图，获取canvas画布图像\r\n        * capturing: 绑定截图到指定按键\r\n    @exp: \r\n        let captuer = new vision.capturer.Capturer(canvas).capturing();\r\n    ----------------------------------------*/\r\n    constructor(canvasObj, fileTitle) {\r\n        //canvas对象\r\n        this.canvasObj = canvasObj;\r\n        //导出文件标题\r\n        this.fileTitle = fileTitle || document.getElementsByTagName(\"title\")[0].innerText.replace(/\\s+/g, \"\");\r\n        //导出文件计数器\r\n        this.fn = 0;\r\n        //截图按键值\r\n        this._capture_keyCode = 'Q'.charCodeAt();\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 获取/设置 截图按键\r\n    ----------------------------------------*/\r\n    get captureKey() { return String.fromCharCode(this._capture_keyCode); }\r\n    set captureKey(key) { this._capture_keyCode = key.charCodeAt(); return this; }\r\n\r\n    /*----------------------------------------\r\n    @func: 截图\r\n    @desc: 导出当前canvas二进制数据\r\n    @params: \r\n        * fileName(str): 导出文件名(可选)\r\n    ----------------------------------------*/\r\n    capture(fileName) {\r\n        //构建文件名\r\n        fileName = fileName || `${this.fileTitle}_${this.fn++}`;\r\n        //导出canvas二进制数据\r\n        this.canvasObj.canvas.toBlob((blob) => {\r\n            let temp_node = document.createElement('a');\r\n            temp_node.style.display = 'none';\r\n            temp_node.id = fileName;\r\n            temp_node.href = window.URL.createObjectURL(blob);\r\n            temp_node.download = `${fileName}.png`; \r\n            temp_node.click();\r\n        })\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 监听截图事件\r\n    @desc: 将截图函数绑定到按键事件上\r\n    ----------------------------------------*/\r\n    capturing() {\r\n        let _this = this;\r\n        //绑定按键监听截图事件\r\n        window.addEventListener(\"keydown\", function(event) {\r\n            if(event.keyCode == _this._capture_keyCode) {\r\n                _this.capture();\r\n            }\r\n        }); \r\n        return this;\r\n    }\r\n}\r\n\r\n\r\nmodule.exports.Capturer = Capturer;\n\n//# sourceURL=webpack://vision/./src/views/capturer.js?");

/***/ }),

/***/ "./src/views/randerer.js":
/*!*******************************!*\
  !*** ./src/views/randerer.js ***!
  \*******************************/
/***/ ((module) => {

eval("/****************************************\r\n * Name: randerer | 渲染器\r\n * Date: 2022-09-06\r\n * Author: Ais\r\n * Project: Vision\r\n * Desc: 渲染器模块\r\n * Version: 0.1\r\n****************************************/\r\n\r\n//渲染器基类\r\nclass Randerer {\r\n\r\n    /*----------------------------------------\r\n    @class: 渲染器基类\r\n    @desc: 渲染器，实现行为逻辑和图像绘制的调度。\r\n    @property: \r\n        * _ft(number:>0): 帧时间轴，时钟\r\n        * fps(number:>0): 帧数(Frames Per Second)\r\n    @method: \r\n        * rander: 渲染接口\r\n    ----------------------------------------*/\r\n    constructor(fps=60) {\r\n        //帧时间轴\r\n        this._ft = 0;\r\n        //帧数(Frames Per Second)\r\n        this.fps = fps;\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 帧时间轴访问器\r\n    @desc: this._ft用于在类内部实现帧的计数, 对外只读\r\n    ----------------------------------------*/\r\n    get ft() { return this._ft; }\r\n\r\n    /*----------------------------------------\r\n    @func: 渲染接口\r\n    ----------------------------------------*/\r\n    rander() { \r\n        this._ft++; \r\n    }\r\n}\r\n\r\n\r\n//间隔渲染器\r\nclass IntervalRanderer extends Randerer {\r\n\r\n    /*----------------------------------------\r\n    @class: 间隔渲染器\r\n    @desc: 标准渲染器，通过 setInterval 函数实现渲染功能\r\n    @property: \r\n        * _stop_ft(number:>0): 渲染器停机时间点\r\n        * _timer(obj): setInterval函数返回对象，用于在停机时停止渲染器\r\n        * rander_func(func): 渲染函数\r\n    @method: \r\n        * rander: 渲染接口\r\n        * stop: 设置停机时间点\r\n    @exp: \r\n        const randerer = new vision.randerer.IntervalRanderer().rander(() => {\r\n            canvas.refresh();\r\n        });\r\n    ----------------------------------------*/\r\n    constructor(fps=60) {\r\n        super(fps);\r\n        //停止时间点\r\n        this._stop_ftp = Infinity;\r\n        //间隔执行器\r\n        this._timer = null;\r\n        //渲染函数\r\n        this.rander_func = null;\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 渲染接口\r\n    @desc: 通过 setInterval 间隔执行 rander_func 实现渲染功能\r\n    @params: \r\n        * rander_func(func): 渲染函数，\r\n        函数形参 => function() || function(ft), ft为帧时间轴，可选参数\r\n    ----------------------------------------*/\r\n    rander(rander_func) {\r\n        this.rander_func = rander_func;\r\n        //构建间隔执行器\r\n        this._timer = setInterval(()=>{\r\n            if(this._ft < this._stop_ftp) {\r\n                //渲染\r\n                this.rander_func(this._ft++);\r\n             } else {\r\n                //停机\r\n                clearInterval(this._timer);\r\n             } \r\n         }, Math.ceil(1000/this.fps));\r\n         return this;\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 设置停机时间点\r\n    ----------------------------------------*/\r\n    stop(t) {\r\n        this._stop_ftp = t; return this;\r\n    }\r\n}\r\n\r\n\r\n//单帧渲染器\r\nclass SingleFrameRanderer extends Randerer {\r\n\r\n    /*----------------------------------------\r\n    @class: 单帧渲染器/手动渲染器\r\n    @desc: 通过绑定按键来控制渲染行为\r\n    @property: \r\n        * act_ft_n(number:>0): 每次触发渲染时，行为函数的调用次数\r\n        * _rander_keyCode(int): 渲染按键值，控制由什么按键进行渲染\r\n        * act_func(func): 行为函数\r\n        * draw_func(func): 绘制函数\r\n    @method: \r\n        * method: func\r\n    @exp: \r\n        const randerer = new vision.randerer.SingleFrameRanderer().rander(\r\n            (ft) => {\r\n                pcs.action();\r\n            },\r\n            (ft) => {\r\n                canvas.refresh();\r\n            }\r\n        );\r\n    ----------------------------------------*/\r\n    constructor(act_ft_n=1) {\r\n        super(1);\r\n        //行为函数调用次数\r\n        this.act_ft_n = act_ft_n;\r\n        //渲染按键值\r\n        this._rander_keyCode = ' '.charCodeAt();\r\n        //行为函数\r\n        this.act_func = null;\r\n        //绘制函数\r\n        this.draw_func = null;\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 获取/设置 渲染按键\r\n    ----------------------------------------*/\r\n    get randerKey() { return String.fromCharCode(this._rander_keyCode); }\r\n    set randerKey(key) { this._rander_keyCode = key.charCodeAt(); }\r\n       \r\n    /*----------------------------------------\r\n    @func: 渲染接口\r\n    @desc: 通过在 window 对象上绑定 keydown 事件来触发渲染\r\n    @params: \r\n        * act_func(func): 行为函数\r\n        * draw_func(func): 绘制函数\r\n    ----------------------------------------*/\r\n    rander(act_func, draw_func) {\r\n        this.act_func = act_func, this.draw_func = draw_func;\r\n        let _this = this;\r\n        //绑定键盘事件\r\n        window.addEventListener(\"keydown\", function(event) {\r\n            if(event.keyCode == _this._rander_keyCode) {\r\n                //行为函数调用\r\n                for(let i=0; i<_this.act_ft_n; i++) {\r\n                    _this.act_func(_this._ft++);\r\n                }\r\n                //绘制函数调用\r\n                _this.draw_func && _this.draw_func(_this._ft);\r\n            }\r\n        }); \r\n        return this;\r\n    }\r\n\r\n}\r\n\r\n\r\n//场景流渲染器\r\nclass SceneFlowRanderer extends Randerer {\r\n\r\n    /*----------------------------------------\r\n    @class: 场景流渲染器\r\n    @desc: 指定 场景函数(scene_func) 和 帧时间点(ftp), 帧时间到达后按照 场景流(scene_flow) 进行场景函数的切换\r\n    @property: \r\n        * key(type): value\r\n    @method: \r\n        * method: func\r\n    @exp: \r\n    ----------------------------------------*/\r\n    constructor(fps=60) {\r\n        super(60);\r\n    }\r\n}\r\n\r\n\r\n// module.exports.Randerer = Randerer;\r\nmodule.exports.IntervalRanderer = IntervalRanderer;\r\nmodule.exports.SingleFrameRanderer = SingleFrameRanderer;\n\n//# sourceURL=webpack://vision/./src/views/randerer.js?");

/***/ }),

/***/ "./src/views/views.js":
/*!****************************!*\
  !*** ./src/views/views.js ***!
  \****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/****************************************\r\n * Name: view | 视图绘制\r\n * Date: 2022-08-01\r\n * Author: Ais\r\n * Project: Vision\r\n * Desc: 常用绘制方法封装\r\n * Version: 0.1\r\n****************************************/\r\n\r\nconst color = __webpack_require__(/*! ../canvas/color */ \"./src/canvas/color.js\");\r\nconst Vector = (__webpack_require__(/*! ../vector/vector */ \"./src/vector/vector.js\").Vector);\r\n\r\n\r\nclass Views {\r\n\r\n    //canvas对象\r\n    canvas = null;\r\n\r\n    /*----------------------------------------\r\n    @func: 节点连接器\r\n    @desc: 绘制点距范围在给定区间内的粒子之间的连线\r\n    @params:\r\n        * ps(list:Particle): 节点粒子\r\n        * dr(list:number): 可绘制的点距范围\r\n        * line_color(list|ColorGradient): 连线的颜色\r\n    ----------------------------------------*/\r\n    static nodelink(ps, dr=[0, 100], line_color=[255, 255, 255]) {\r\n        //粒子点距范围\r\n        let pdr = (typeof dr === \"number\") ? [0, dr] : dr;\r\n        let d = pdr[1] - pdr[0];\r\n        //颜色向量|颜色渐变器\r\n        let cv = line_color.color ? line_color : new color.ColorVector(...line_color);\r\n        //绘制\r\n        for(let i=0, n=ps.length; i<n; i++) {\r\n            let c = cv.color(true);\r\n            for(let k=i; k<n; k++) {\r\n                //计算点距\r\n                let pd = ps[i].p.dist(ps[k].p);\r\n                if(pd >= pdr[0] && pd <= pdr[1]) {\r\n                    Views.canvas.ctx.strokeStyle = `rgb(${c[0]}, ${c[1]}, ${c[2]}, ${1-pd/d})`;\r\n                    Views.canvas.line(ps[i].p, ps[k].p);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 绘制网格\r\n    @params: \r\n        * co(Vector): 网格中心坐标\r\n        * dx(number,>0): 网格单元长度\r\n        * dy(number,>0): 网格单元高度\r\n        * xR(list:int): x轴坐标范围\r\n        * yR(list:int): y轴坐标范围\r\n        * color(list:int): 线段颜色\r\n        * center(bool): 网格坐标是否居中 -> true(中心坐标位于线段交界点) | false(中心坐标位于网格单元中心)\r\n    @exp: \r\n        Views.grid({co: grid.co, dx: grid.dx, dy: grid.dy});\r\n    ----------------------------------------*/\r\n    static grid({co, dx, dy, xR, yR, color=[255, 255, 255], center=true}) {\r\n        //中心坐标\r\n        co = co || new Vector(Views.canvas.cx, Views.canvas.cy);\r\n        //网格单元尺寸\r\n        dy = dy || dx;\r\n        //x轴范围\r\n        xR = xR || [-parseInt(Views.canvas.cx/dx)-1, parseInt(Views.canvas.cx/dx)+1];\r\n        let xs = xR[0]*dx+co.x, xe = xR[1]*dx+co.x;\r\n        //y轴范围\r\n        yR = yR || [-parseInt(Views.canvas.cy/dy)-1, parseInt(Views.canvas.cy/dy)+1];\r\n        let ys = yR[0]*dy+co.y, ye = yR[1]*dy+co.y;\r\n        //居中偏移量\r\n        let cdx = (center ? 0 : dx/2), cdy = (center ? 0 : dy/2); \r\n        //设置颜色\r\n        Views.canvas.ctx.strokeStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]}, ${color[3]||0.25})`\r\n        //绘制x轴平行线\r\n        for(let x=xR[0], n=xR[1]; x<=n; x++) {\r\n            let _x = x*dx+co.x+cdx;\r\n            Views.canvas.line(_x, ys, _x, ye);\r\n        }\r\n        //绘制y轴平行线\r\n        for(let y=yR[0], n=yR[1]; y<=n; y++) {\r\n            let _y = y*dy+co.y+cdy;\r\n            Views.canvas.line(xs, _y, xe, _y);\r\n        }\r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 光线\r\n    @params:\r\n        * ps(list:Vector): 线的点集\r\n        * Lfx(function): 亮度衰减函数(Lfx应满足在[1, n]区间单调递减)\r\n        * n(int:>0): 光线的层数\r\n        * d(number:>0): 每次光线的宽度\r\n        * cs(list): 起始颜色\r\n        * ce(list): 终止颜色\r\n    ----------------------------------------*/\r\n    static lightLine(ps, {Lfx, n=10, d=3, cs=[255, 255, 255], ce=[0, 0, 0]} = {}) {\r\n        //亮度衰减函数\r\n        Lfx = Lfx || ((x) => {return 1/(x+0.0001);});\r\n        //Lfx函数在[1, n]区间的最值, 用于进行后续归一化处理\r\n        let max = Lfx(1), min = Lfx(n);\r\n        //绘制光线\r\n        Views.canvas.ctx.lineCap = \"round\";\r\n        for(let i=n; i>0; i--) {\r\n            //计算亮度\r\n            let lr = (Lfx(i) - min) / (max - min);\r\n            let lc = [(cs[0]-ce[0])*lr+ce[0], (cs[1]-ce[1])*lr+ce[1], (cs[2]-ce[2])*lr+ce[2]];\r\n            //绘制光线层\r\n            Views.canvas.ctx.lineWidth = i * d;\r\n            Views.canvas.lines(ps, new color.ColorGradient(lc, ce, ps.length));\r\n        }  \r\n    }\r\n\r\n    /*----------------------------------------\r\n    @func: 光环\r\n    @params: \r\n        * x, y, r(number): 圆心坐标与半径\r\n        * Lfx(function): 亮度衰减函数(Lfx应满足在[1, n]区间单调递减)\r\n        * n(int:>0): 光线的层数\r\n        * cs(list): 起始颜色\r\n        * ce(list): 终止颜色\r\n        * point(bool): true->绘制成光点样式\r\n    ----------------------------------------*/\r\n    static lightRing(x, y, r, {Lfx, n=50, cs=[255, 255, 255], ce=[0, 0, 0], point=false}={}) {\r\n        //亮度衰减函数\r\n        Lfx = Lfx || ((x) => {return 1/(x+0.0001);});\r\n        //Lfx函数在[1, n]区间的最值, 用于进行后续归一化处理\r\n        let max = Lfx(1), min = Lfx(n);\r\n        //计算环宽\r\n        let dR = r / n;\r\n        //绘制\r\n        for(let i=n; i>0; i--) {\r\n            //计算亮度\r\n            let lr = (Lfx(point ? i : n-i) - min) / (max - min);\r\n            let lc = [(cs[0]-ce[0])*lr+ce[0], (cs[1]-ce[1])*lr+ce[1], (cs[2]-ce[2])*lr+ce[2]];\r\n            //绘制光环\r\n            Views.canvas.colorStyle = `rgb(${lc[0]}, ${lc[1]}, ${lc[2]})`;\r\n            Views.canvas.circle(x, y, dR*i);\r\n            Views.canvas.ctx.fill();\r\n        }  \r\n    }\r\n}\r\n\r\n\r\nmodule.exports.Views = Views;\r\n\r\n\n\n//# sourceURL=webpack://vision/./src/views/views.js?");

/***/ }),

/***/ "./src/viewtools/point_capturer.js":
/*!*****************************************!*\
  !*** ./src/viewtools/point_capturer.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/****************************************\r\n * Name: point_capturer\r\n * Date: 2022-07-12\r\n * Author: Ais\r\n * Project: Vision\r\n * Desc: 捕获鼠标点击坐标\r\n * Version: 0.1\r\n****************************************/\r\n\r\nconst Vector = (__webpack_require__(/*! ../vector/vector */ \"./src/vector/vector.js\").Vector);\r\n\r\n\r\nclass PointCapturer {\r\n\r\n    /*----------------------------------------\r\n    @name: 坐标捕获器\r\n    @desc: 捕获鼠标点击的坐标点\r\n    @property: \r\n        * canvas(Canvas): 绘制容器\r\n        * points(list): 坐标点容器，存储捕获的坐标点\r\n        * p(Vector): 当前鼠标坐标\r\n        * style(obj): 坐标点的绘制样式\r\n        * is_vector(bool): 坐标点的存储类型 -> true(Vector(x, y)) || false([x, y])\r\n        * is_disp(bool): 是否绘制捕获的坐标点\r\n        * is_line(bool): 是否将坐标连线\r\n        * is_close(bool): 当is_line=true, 是否绘制闭合线\r\n    @return(type): \r\n    @exp: \r\n    ----------------------------------------*/\r\n    constructor(canvas) {\r\n        //canvas容器\r\n        this.canvas = canvas;\r\n        //坐标点容器\r\n        this.points = [];\r\n        //当前坐标\r\n        this.p = new Vector(0, 0);\r\n        //坐标点样式\r\n        this.style = {\r\n            //半径\r\n            r: 3,\r\n            //颜色\r\n            c: 'rgb(255, 255, 255)'\r\n        }\r\n        //坐标点类型\r\n        this.is_vector = true;\r\n        //是否绘制坐标点\r\n        this.is_disp = false;\r\n        //是否连线\r\n        this.is_line = false;\r\n        //连线是否闭合\r\n        this.is_close = false\r\n    }\r\n\r\n    //捕获\r\n    capture(element_id) {\r\n        let _this = this;\r\n        document.getElementById(element_id).addEventListener(\"mousemove\", function(event) {\r\n            _this.p = new Vector(event.clientX, event.clientY);\r\n        });\r\n        document.getElementById(element_id).addEventListener(\"mousedown\", function(event) {\r\n            //添加坐标点\r\n            if(event.button == 0) {\r\n                let x = event.clientX, y = event.clientY;\r\n                _this.points.push(_this.is_vector ? new Vector(x, y) : [x, y]);\r\n                _this.is_disp && _this.disp();\r\n            //清空坐标点\r\n            } else if(event.button == 2) {\r\n                _this.points = [];\r\n                _this.is_disp && _this.canvas.refresh();\r\n            }\r\n        });\r\n    }\r\n\r\n    //绘制\r\n    disp() {\r\n        this.canvas.refresh();\r\n        //绘制当前坐标点\r\n        this.canvas.colorStyle = this.style.c;\r\n        this.canvas.circle(this.p.x, this.p.y, this.style.r);\r\n        this.canvas.ctx.fill();\r\n        //绘制捕获的坐标点\r\n        for(let i=0, end=this.points.length; i<end; i++) {\r\n            this.canvas.colorStyle = this.style.c;\r\n            if(this.is_vector) {\r\n                this.canvas.circle(this.points[i].x, this.points[i].y, this.style.r);\r\n            } else {\r\n                this.canvas.circle(this.points[i][0], this.points[i][1], this.style.r);\r\n            }\r\n            this.canvas.ctx.fill();\r\n        }\r\n        if(this.is_line) {\r\n            this.canvas.ctx.strokeStyle = this.style.c;\r\n            this.canvas.lines(this.points, this.is_close);\r\n        }\r\n    }\r\n\r\n    //导出\r\n    export(to_str=false) {\r\n        let _points = this.points;\r\n        if(this.is_vector) {\r\n            _points = [];\r\n            for(let i=0, end=this.points.length; i<end; i++) {\r\n                _points.push([this.points[i].x, this.points[i].y]);\r\n            }\r\n        } \r\n        return to_str==false ? _points : JSON.stringify(_points);\r\n    }\r\n}\r\n\r\n\r\nmodule.exports.PointCapturer = PointCapturer;\n\n//# sourceURL=webpack://vision/./src/viewtools/point_capturer.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./build/index.js");
/******/ 	vision = __webpack_exports__;
/******/ 	
/******/ })()
;